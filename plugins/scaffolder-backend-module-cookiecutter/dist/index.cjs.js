'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var backendCommon = require('@backstage/backend-common');
var errors = require('@backstage/errors');
var commandExists = require('command-exists');
var fs = require('fs-extra');
var path = require('path');
var pluginScaffolderBackend = require('@backstage/plugin-scaffolder-backend');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var commandExists__default = /*#__PURE__*/_interopDefaultLegacy(commandExists);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

class CookiecutterRunner {
  constructor({ containerRunner }) {
    this.containerRunner = containerRunner;
  }
  async fetchTemplateCookieCutter(directory) {
    try {
      return await fs__default["default"].readJSON(path__default["default"].join(directory, "cookiecutter.json"));
    } catch (ex) {
      if (ex.code !== "ENOENT") {
        throw ex;
      }
      return {};
    }
  }
  async run({
    workspacePath,
    values,
    logStream,
    imageName,
    templateDir,
    templateContentsDir
  }) {
    const intermediateDir = path__default["default"].join(workspacePath, "intermediate");
    await fs__default["default"].ensureDir(intermediateDir);
    const resultDir = path__default["default"].join(workspacePath, "result");
    const cookieCutterJson = await this.fetchTemplateCookieCutter(templateContentsDir);
    const cookieInfo = {
      ...cookieCutterJson,
      ...values
    };
    await fs__default["default"].writeJSON(path__default["default"].join(templateDir, "cookiecutter.json"), cookieInfo);
    const mountDirs = {
      [templateDir]: "/input",
      [intermediateDir]: "/output"
    };
    const cookieCutterInstalled = await commandExists__default["default"]("cookiecutter").catch(() => false);
    if (cookieCutterInstalled) {
      await pluginScaffolderBackend.executeShellCommand({
        command: "cookiecutter",
        args: ["--no-input", "-o", intermediateDir, templateDir, "--verbose"],
        logStream
      });
    } else {
      await this.containerRunner.runContainer({
        imageName: imageName != null ? imageName : "spotify/backstage-cookiecutter",
        command: "cookiecutter",
        args: ["--no-input", "-o", "/output", "/input", "--verbose"],
        mountDirs,
        workingDir: "/input",
        envVars: { HOME: "/tmp" },
        logStream
      });
    }
    const [generated] = await fs__default["default"].readdir(intermediateDir);
    if (generated === void 0) {
      throw new Error("No data generated by cookiecutter");
    }
    await fs__default["default"].move(path__default["default"].join(intermediateDir, generated), resultDir);
  }
}
function createFetchCookiecutterAction(options) {
  const { reader, containerRunner, integrations } = options;
  return pluginScaffolderBackend.createTemplateAction({
    id: "fetch:cookiecutter",
    description: "Downloads a template from the given URL into the workspace, and runs cookiecutter on it.",
    schema: {
      input: {
        type: "object",
        required: ["url"],
        properties: {
          url: {
            title: "Fetch URL",
            description: "Relative path or absolute URL pointing to the directory tree to fetch",
            type: "string"
          },
          targetPath: {
            title: "Target Path",
            description: "Target path within the working directory to download the contents to.",
            type: "string"
          },
          values: {
            title: "Template Values",
            description: "Values to pass on to cookiecutter for templating",
            type: "object"
          },
          copyWithoutRender: {
            title: "Copy Without Render",
            description: "Avoid rendering directories and files in the template",
            type: "array",
            items: {
              type: "string"
            }
          },
          extensions: {
            title: "Template Extensions",
            description: "Jinja2 extensions to add filters, tests, globals or extend the parser. Extensions must be installed in the container or on the host where Cookiecutter executes. See the contrib directory in Backstage's repo for more information",
            type: "array",
            items: {
              type: "string"
            }
          },
          imageName: {
            title: "Cookiecutter Docker image",
            description: "Specify a custom Docker image to run cookiecutter, to override the default: 'spotify/backstage-cookiecutter'. This can be used to execute cookiecutter with Template Extensions. Used only when a local cookiecutter is not found.",
            type: "string"
          }
        }
      }
    },
    async handler(ctx) {
      var _a, _b;
      ctx.logger.info("Fetching and then templating using cookiecutter");
      const workDir = await ctx.createTemporaryDirectory();
      const templateDir = path.resolve(workDir, "template");
      const templateContentsDir = path.resolve(templateDir, "{{cookiecutter and 'contents'}}");
      const resultDir = path.resolve(workDir, "result");
      if (ctx.input.copyWithoutRender && !Array.isArray(ctx.input.copyWithoutRender)) {
        throw new errors.InputError("Fetch action input copyWithoutRender must be an Array");
      }
      if (ctx.input.extensions && !Array.isArray(ctx.input.extensions)) {
        throw new errors.InputError("Fetch action input extensions must be an Array");
      }
      await pluginScaffolderBackend.fetchContents({
        reader,
        integrations,
        baseUrl: (_a = ctx.templateInfo) == null ? void 0 : _a.baseUrl,
        fetchUrl: ctx.input.url,
        outputPath: templateContentsDir
      });
      const cookiecutter = new CookiecutterRunner({ containerRunner });
      const values = {
        ...ctx.input.values,
        _copy_without_render: ctx.input.copyWithoutRender,
        _extensions: ctx.input.extensions
      };
      await cookiecutter.run({
        workspacePath: workDir,
        logStream: ctx.logStream,
        values,
        imageName: ctx.input.imageName,
        templateDir,
        templateContentsDir
      });
      const targetPath = (_b = ctx.input.targetPath) != null ? _b : "./";
      const outputPath = backendCommon.resolveSafeChildPath(ctx.workspacePath, targetPath);
      await fs__default["default"].copy(resultDir, outputPath);
    }
  });
}

exports.createFetchCookiecutterAction = createFetchCookiecutterAction;
//# sourceMappingURL=index.cjs.js.map
