/// <reference types="react" />
import React$1, { ReactNode, PropsWithChildren } from 'react';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';

declare const SEMVER_PARTS: {
    major: 'major';
    minor: 'minor';
    patch: 'patch';
};
declare const DISABLE_CACHE: {
    readonly headers: {
        readonly 'If-None-Match': "";
    };
};
declare const VERSIONING_STRATEGIES: {
    semver: 'semver';
    calver: 'calver';
};
declare const TAG_OBJECT_MESSAGE = "Tag generated by your friendly neighborhood Backstage Release Manager";

declare const constants_SEMVER_PARTS: typeof SEMVER_PARTS;
declare const constants_DISABLE_CACHE: typeof DISABLE_CACHE;
declare const constants_VERSIONING_STRATEGIES: typeof VERSIONING_STRATEGIES;
declare const constants_TAG_OBJECT_MESSAGE: typeof TAG_OBJECT_MESSAGE;
declare namespace constants {
  export {
    constants_SEMVER_PARTS as SEMVER_PARTS,
    constants_DISABLE_CACHE as DISABLE_CACHE,
    constants_VERSIONING_STRATEGIES as VERSIONING_STRATEGIES,
    constants_TAG_OBJECT_MESSAGE as TAG_OBJECT_MESSAGE,
  };
}

interface Project {
    /**
     * Repository's owner (user or organisation)
     *
     * @example erikengervall
     */
    owner: string;
    /**
     * Repository's name
     *
     * @example dockest
     */
    repo: string;
    /**
     * Declares the versioning strategy of the project
     *
     * semver: `1.2.3` (major.minor.patch)
     * calver: `2020.01.01_0` (YYYY.0M.0D_patch)
     *
     * Default: false
     */
    versioningStrategy: keyof typeof VERSIONING_STRATEGIES;
    /**
     * Project props was provided via props
     *
     * If true, this means select inputs will be disabled
     */
    isProvidedViaProps: boolean;
}

declare type UnboxPromise<T extends Promise<any>> = T extends Promise<infer U> ? U : never;
declare type UnboxReturnedPromise<T extends (...args: any) => Promise<any>> = UnboxPromise<ReturnType<T>>;
declare type UnboxArray<T> = T extends (infer U)[] ? U : T;

declare type OwnerRepo = {
    owner: Project['owner'];
    repo: Project['repo'];
};
interface GitReleaseApi {
    getHost: () => string;
    getRepoPath: (args: OwnerRepo) => string;
    getOwners: () => Promise<{
        owners: string[];
    }>;
    getRepositories: (args: {
        owner: OwnerRepo['owner'];
    }) => Promise<{
        repositories: string[];
    }>;
    getUser: (args: OwnerRepo) => Promise<{
        user: {
            username: string;
            email?: string;
        };
    }>;
    getRecentCommits: (args: {
        releaseBranchName?: string;
    } & OwnerRepo) => Promise<{
        recentCommits: {
            htmlUrl: string;
            sha: string;
            author: {
                htmlUrl?: string;
                login?: string;
            };
            commit: {
                message: string;
            };
            firstParentSha?: string;
        }[];
    }>;
    getLatestRelease: (args: OwnerRepo) => Promise<{
        latestRelease: {
            targetCommitish: string;
            tagName: string;
            prerelease: boolean;
            id: number;
            htmlUrl: string;
            body?: string | null;
        } | null;
    }>;
    getRepository: (args: OwnerRepo) => Promise<{
        repository: {
            pushPermissions: boolean | undefined;
            defaultBranch: string;
            name: string;
        };
    }>;
    getCommit: (args: {
        ref: string;
    } & OwnerRepo) => Promise<{
        commit: {
            sha: string;
            htmlUrl: string;
            commit: {
                message: string;
            };
            createdAt?: string;
        };
    }>;
    getBranch: (args: {
        branch: string;
    } & OwnerRepo) => Promise<{
        branch: {
            name: string;
            links: {
                html: string;
            };
            commit: {
                sha: string;
                commit: {
                    tree: {
                        sha: string;
                    };
                };
            };
        };
    }>;
    createRef: (args: {
        ref: string;
        sha: string;
    } & OwnerRepo) => Promise<{
        reference: {
            ref: string;
            objectSha: string;
        };
    }>;
    deleteRef: (args: {
        ref: string;
    } & OwnerRepo) => Promise<{
        success: boolean;
    }>;
    getComparison: (args: {
        base: string;
        head: string;
    } & OwnerRepo) => Promise<{
        comparison: {
            htmlUrl: string;
            aheadBy: number;
        };
    }>;
    createRelease: (args: {
        tagName: string;
        name: string;
        targetCommitish: string;
        body: string;
    } & OwnerRepo) => Promise<{
        release: {
            name: string | null;
            htmlUrl: string;
            tagName: string;
        };
    }>;
    createTagObject: (args: {
        tag: string;
        taggerEmail?: string;
        message: string;
        object: string;
        taggerName: string;
    } & OwnerRepo) => Promise<{
        tagObject: {
            tagName: string;
            tagSha: string;
        };
    }>;
    createCommit: (args: {
        message: string;
        tree: string;
        parents: string[];
    } & OwnerRepo) => Promise<{
        commit: {
            message: string;
            sha: string;
        };
    }>;
    updateRef: (args: {
        sha: string;
        ref: string;
        force: boolean;
    } & OwnerRepo) => Promise<{
        reference: {
            ref: string;
            object: {
                sha: string;
            };
        };
    }>;
    merge: (args: {
        base: string;
        head: string;
    } & OwnerRepo) => Promise<{
        merge: {
            htmlUrl: string;
            commit: {
                message: string;
                tree: {
                    sha: string;
                };
            };
        };
    }>;
    updateRelease: (args: {
        releaseId: number;
        tagName: string;
        body?: string;
        prerelease?: boolean;
    } & OwnerRepo) => Promise<{
        release: {
            name: string | null;
            tagName: string;
            htmlUrl: string;
        };
    }>;
    /**
     * Get all tags in descending order
     */
    getAllTags: (args: OwnerRepo) => Promise<{
        tags: Array<{
            tagName: string;
            tagSha: string;
            tagType: 'tag' | 'commit';
        }>;
    }>;
    getAllReleases: (args: OwnerRepo) => Promise<{
        releases: Array<{
            id: number;
            name: string | null;
            tagName: string;
            createdAt: string | null;
            htmlUrl: string;
        }>;
    }>;
    getTag: (args: {
        tagSha: string;
    } & OwnerRepo) => Promise<{
        tag: {
            date: string;
            username: string;
            userEmail: string;
            objectSha: string;
        };
    }>;
}
declare type GetRecentCommitsResult = UnboxReturnedPromise<GitReleaseApi['getRecentCommits']>;
declare type GetRecentCommitsResultSingle = UnboxArray<GetRecentCommitsResult['recentCommits']>;
declare type GetLatestReleaseResult = UnboxReturnedPromise<GitReleaseApi['getLatestRelease']>;
declare type GetRepositoryResult = UnboxReturnedPromise<GitReleaseApi['getRepository']>;
declare type GetCommitResult = UnboxReturnedPromise<GitReleaseApi['getCommit']>;
declare type GetBranchResult = UnboxReturnedPromise<GitReleaseApi['getBranch']>;
declare type GetTagResult = UnboxReturnedPromise<GitReleaseApi['getTag']>;

interface GetReleaseCandidateGitInfo {
    project: Project;
    latestRelease: GetLatestReleaseResult['latestRelease'];
    semverBumpLevel: keyof typeof SEMVER_PARTS;
    injectedDate?: string;
}
declare const getReleaseCandidateGitInfo: ({ project, latestRelease, semverBumpLevel, injectedDate, }: GetReleaseCandidateGitInfo) => {
    rcBranch: string;
    rcReleaseTag: string;
    releaseName: string;
    error?: undefined;
} | {
    error: AlertError;
    rcBranch?: undefined;
    rcReleaseTag?: undefined;
    releaseName?: undefined;
};

interface UseCreateReleaseCandidate {
    defaultBranch: GetRepositoryResult['repository']['defaultBranch'];
    latestRelease: GetLatestReleaseResult['latestRelease'];
    releaseCandidateGitInfo: ReturnType<typeof getReleaseCandidateGitInfo>;
    project: Project;
    onSuccess?: ComponentConfig<CreateRcOnSuccessArgs>['onSuccess'];
}

declare type CalverTagParts = {
    prefix: string;
    calver: string;
    patch: number;
};
declare const calverRegexp: RegExp;
declare function getCalverTagParts(tag: string): {
    error: AlertError;
    tagParts?: undefined;
} | {
    tagParts: CalverTagParts;
    error?: undefined;
};

declare type SemverTagParts = {
    prefix: string;
    major: number;
    minor: number;
    patch: number;
};
declare const semverRegexp: RegExp;
declare function getSemverTagParts(tag: string): {
    error: AlertError;
    tagParts?: undefined;
} | {
    tagParts: SemverTagParts;
    error?: undefined;
};

interface UsePatch {
    bumpedTag: string;
    latestRelease: NonNullable<GetLatestReleaseResult['latestRelease']>;
    project: Project;
    tagParts: NonNullable<CalverTagParts | SemverTagParts>;
    onSuccess?: ComponentConfig<PatchOnSuccessArgs>['onSuccess'];
}

interface UsePromoteRc {
    rcRelease: NonNullable<GetLatestReleaseResult['latestRelease']>;
    releaseVersion: string;
    onSuccess?: ComponentConfig<PromoteRcOnSuccessArgs>['onSuccess'];
}

declare type ComponentConfig<OnSuccessArgs> = {
    omit?: boolean;
    onSuccess?: (args: OnSuccessArgs) => Promise<void> | void;
};
interface CreateRcOnSuccessArgs {
    input: Omit<UseCreateReleaseCandidate, 'onSuccess'>;
    comparisonUrl: string;
    createdTag: string;
    gitReleaseName: string | null;
    gitReleaseUrl: string;
    previousTag?: string;
}
interface PromoteRcOnSuccessArgs {
    input: Omit<UsePromoteRc, 'onSuccess'>;
    gitReleaseUrl: string;
    gitReleaseName: string | null;
    previousTagUrl: string;
    previousTag: string;
    updatedTagUrl: string;
    updatedTag: string;
}
interface PatchOnSuccessArgs {
    input: Omit<UsePatch, 'onSuccess'>;
    updatedReleaseUrl: string;
    updatedReleaseName: string | null;
    previousTag: string;
    patchedTag: string;
    patchCommitUrl: string;
    patchCommitMessage: string;
}
interface ResponseStep {
    message: React.ReactNode;
    secondaryMessage?: string | React.ReactNode;
    link?: string;
    icon?: 'success' | 'failure';
}
interface AlertError {
    title?: string;
    subtitle: string;
}

interface GitReleaseManagerProps {
    project?: Omit<Project, 'isProvidedViaProps'>;
    features?: {
        info?: Pick<ComponentConfig<void>, 'omit'>;
        stats?: Pick<ComponentConfig<void>, 'omit'>;
        createRc?: ComponentConfig<CreateRcOnSuccessArgs>;
        promoteRc?: ComponentConfig<PromoteRcOnSuccessArgs>;
        patch?: ComponentConfig<PatchOnSuccessArgs>;
        custom?: {
            factory: ({ latestRelease, project, releaseBranch, repository, }: {
                latestRelease: GetLatestReleaseResult['latestRelease'] | null;
                project: Project;
                releaseBranch: GetBranchResult['branch'] | null;
                repository: GetRepositoryResult['repository'];
            }) => React$1.ReactElement | React$1.ReactElement[];
        };
    };
}
declare function GitReleaseManager(props: GitReleaseManagerProps): JSX.Element;

declare const gitReleaseManagerApiRef: _backstage_core_plugin_api.ApiRef<GitReleaseApi>;

/**
 * Calculates the next version for the project
 *
 * For calendar versioning this means a bump in patch
 *
 * For semantic versioning this means either a minor or a patch bump
 * depending on the value of `bumpLevel`
 */
declare function getBumpedTag({ project, tag, bumpLevel, }: {
    project: Project;
    tag: string;
    bumpLevel: keyof typeof SEMVER_PARTS;
}): {
    bumpedTag: string;
    tagParts: CalverTagParts;
    error: undefined;
} | {
    bumpedTag: string;
    tagParts: {
        prefix: string;
        major: number;
        minor: number;
        patch: number;
    };
    error: undefined;
} | {
    error: AlertError;
};
/**
 * Calculates the next semantic version, taking into account
 * whether or not it's a minor or patch
 */
declare function getBumpedSemverTagParts(tagParts: SemverTagParts, semverBumpLevel: keyof typeof SEMVER_PARTS): {
    bumpedTagParts: {
        prefix: string;
        major: number;
        minor: number;
        patch: number;
    };
};

declare function getShortCommitHash(hash: string): string;

/**
 * Tag parts are the individual parts of a version, e.g. <major>.<minor>.<patch>
 * are the parts of a semantic version
 */
declare function getTagParts({ project, tag, }: {
    project: Project;
    tag: string;
}): {
    error: AlertError;
    tagParts?: undefined;
} | {
    tagParts: CalverTagParts;
    error?: undefined;
} | {
    tagParts: SemverTagParts;
    error?: undefined;
};

declare function isCalverTagParts(project: Project, _tagParts: unknown): _tagParts is CalverTagParts;

declare function isProjectValid(project: any): project is Project;

declare const validateTagName: ({ project, tagName, }: {
    project: Project;
    tagName?: string | undefined;
}) => {
    tagNameError: null;
} | {
    tagNameError: AlertError | undefined;
};

declare const helpers_calverRegexp: typeof calverRegexp;
declare const helpers_getCalverTagParts: typeof getCalverTagParts;
declare const helpers_getBumpedSemverTagParts: typeof getBumpedSemverTagParts;
declare const helpers_getBumpedTag: typeof getBumpedTag;
declare const helpers_getSemverTagParts: typeof getSemverTagParts;
declare const helpers_semverRegexp: typeof semverRegexp;
declare const helpers_getShortCommitHash: typeof getShortCommitHash;
declare const helpers_getTagParts: typeof getTagParts;
declare const helpers_isCalverTagParts: typeof isCalverTagParts;
declare const helpers_isProjectValid: typeof isProjectValid;
declare const helpers_validateTagName: typeof validateTagName;
declare namespace helpers {
  export {
    helpers_calverRegexp as calverRegexp,
    helpers_getCalverTagParts as getCalverTagParts,
    helpers_getBumpedSemverTagParts as getBumpedSemverTagParts,
    helpers_getBumpedTag as getBumpedTag,
    helpers_getSemverTagParts as getSemverTagParts,
    helpers_semverRegexp as semverRegexp,
    helpers_getShortCommitHash as getShortCommitHash,
    helpers_getTagParts as getTagParts,
    helpers_isCalverTagParts as isCalverTagParts,
    helpers_isProjectValid as isProjectValid,
    helpers_validateTagName as validateTagName,
  };
}

interface DifferProps {
    icon: 'tag' | 'branch' | 'github' | 'slack' | 'versioning';
    current?: string;
    next?: string | ReactNode;
}
declare const Differ: ({ current, next, icon }: DifferProps) => JSX.Element;

declare const Divider: () => JSX.Element;

declare const InfoCardPlus: ({ children }: {
    children?: React$1.ReactNode;
}) => JSX.Element;

declare function LinearProgressWithLabel(props: {
    progress: number;
    responseSteps: ResponseStep[];
}): JSX.Element;

declare const NoLatestRelease: () => JSX.Element;

interface DialogProps {
    progress: number;
    responseSteps: ResponseStep[];
    title: string;
}
declare const ResponseStepDialog: ({ progress, responseSteps, title, }: DialogProps) => JSX.Element;

interface ResponseStepListProps {
    responseSteps: (ResponseStep | undefined)[];
    animationDelay?: number;
    loading?: boolean;
    closeable?: boolean;
    denseList?: boolean;
}
declare const ResponseStepList: ({ responseSteps, animationDelay, loading, denseList, children, }: PropsWithChildren<ResponseStepListProps>) => JSX.Element;

interface ResponseStepListItemProps {
    responseStep: ResponseStep;
    index: number;
    animationDelay?: number;
}
declare const ResponseStepListItem: ({ responseStep, animationDelay, }: ResponseStepListItemProps) => JSX.Element;

declare const components_Differ: typeof Differ;
declare const components_Divider: typeof Divider;
declare const components_InfoCardPlus: typeof InfoCardPlus;
declare const components_LinearProgressWithLabel: typeof LinearProgressWithLabel;
declare const components_NoLatestRelease: typeof NoLatestRelease;
declare const components_ResponseStepDialog: typeof ResponseStepDialog;
declare const components_ResponseStepList: typeof ResponseStepList;
declare const components_ResponseStepListItem: typeof ResponseStepListItem;
declare namespace components {
  export {
    components_Differ as Differ,
    components_Divider as Divider,
    components_InfoCardPlus as InfoCardPlus,
    components_LinearProgressWithLabel as LinearProgressWithLabel,
    components_NoLatestRelease as NoLatestRelease,
    components_ResponseStepDialog as ResponseStepDialog,
    components_ResponseStepList as ResponseStepList,
    components_ResponseStepListItem as ResponseStepListItem,
  };
}

interface ReleaseStats {
    unmappableTags: string[];
    unmatchedTags: string[];
    unmatchedReleases: string[];
    releases: {
        [baseVersion: string]: {
            baseVersion: string;
            createdAt: string | null;
            htmlUrl: string;
            candidates: {
                tagName: string;
                tagSha: string;
                tagType: 'tag' | 'commit';
            }[];
            versions: {
                tagName: string;
                tagSha: string;
                tagType: 'tag' | 'commit';
            }[];
        };
    };
}

declare const mockReleaseStats: ReleaseStats;

declare const stats_d_mockReleaseStats: typeof mockReleaseStats;
declare namespace stats_d {
  export {
    stats_d_mockReleaseStats as mockReleaseStats,
  };
}

declare const mockUsername = "mock_username";
declare const mockEmail = "mock_email";
declare const mockOwner = "mock_owner";
declare const mockRepo = "mock_repo";
declare const A_CALVER_VERSION = "2020.01.01_1";
declare const MOCK_RELEASE_NAME_CALVER: string;
declare const MOCK_RELEASE_BRANCH_NAME_CALVER: string;
declare const MOCK_RELEASE_CANDIDATE_TAG_NAME_CALVER: string;
declare const MOCK_RELEASE_VERSION_TAG_NAME_CALVER: string;
declare const A_SEMVER_VERSION = "1.2.3";
declare const MOCK_RELEASE_NAME_SEMVER: string;
declare const MOCK_RELEASE_BRANCH_NAME_SEMVER: string;
declare const MOCK_RELEASE_CANDIDATE_TAG_NAME_SEMVER: string;
declare const MOCK_RELEASE_VERSION_TAG_NAME_SEMVER: string;
declare const createMockTag: (overrides: Partial<GetTagResult['tag']>) => GetTagResult;
declare const createMockCommit: (overrides: Partial<GetCommitResult['commit']>) => GetCommitResult;
declare const mockUser: {
    username: string;
    email: string;
};
declare const mockSemverProject: Project;
declare const mockCalverProject: Project;
declare const mockSearchCalver: string;
declare const mockSearchSemver: string;
declare const mockDefaultBranch = "mock_defaultBranch";
declare const mockNextGitInfoSemver: ReturnType<typeof getReleaseCandidateGitInfo>;
declare const mockNextGitInfoCalver: ReturnType<typeof getReleaseCandidateGitInfo>;
declare const mockTagParts: CalverTagParts;
declare const mockCtaMessage = "Patch Release Candidate";
declare const mockBumpedTag = "rc-2020.01.01_1337";
/**
 * MOCK RELEASE
 */
declare const createMockRelease: ({ id, prerelease, ...rest }?: Partial<NonNullable<GetLatestReleaseResult['latestRelease']>>) => NonNullable<GetLatestReleaseResult['latestRelease']>;
declare const mockReleaseCandidateCalver: {
    targetCommitish: string;
    tagName: string;
    prerelease: boolean;
    id: number;
    htmlUrl: string;
    body?: string | null | undefined;
};
declare const mockReleaseVersionCalver: {
    targetCommitish: string;
    tagName: string;
    prerelease: boolean;
    id: number;
    htmlUrl: string;
    body?: string | null | undefined;
};
declare const mockReleaseCandidateSemver: {
    targetCommitish: string;
    tagName: string;
    prerelease: boolean;
    id: number;
    htmlUrl: string;
    body?: string | null | undefined;
};
declare const mockReleaseVersionSemver: {
    targetCommitish: string;
    tagName: string;
    prerelease: boolean;
    id: number;
    htmlUrl: string;
    body?: string | null | undefined;
};
/**
 * MOCK BRANCH
 */
declare const createMockBranch: ({ ...rest }?: Partial<GetBranchResult>) => GetBranchResult['branch'];
declare const mockReleaseBranch: {
    name: string;
    links: {
        html: string;
    };
    commit: {
        sha: string;
        commit: {
            tree: {
                sha: string;
            };
        };
    };
};
/**
 * MOCK COMMIT
 */
declare const createMockRecentCommit: ({ ...rest }: Partial<GetRecentCommitsResultSingle>) => GetRecentCommitsResultSingle;
declare const mockSelectedPatchCommit: {
    htmlUrl: string;
    sha: string;
    author: {
        htmlUrl?: string | undefined;
        login?: string | undefined;
    };
    commit: {
        message: string;
    };
    firstParentSha?: string | undefined;
};

declare const testHelpers_d_mockUsername: typeof mockUsername;
declare const testHelpers_d_mockEmail: typeof mockEmail;
declare const testHelpers_d_mockOwner: typeof mockOwner;
declare const testHelpers_d_mockRepo: typeof mockRepo;
declare const testHelpers_d_A_CALVER_VERSION: typeof A_CALVER_VERSION;
declare const testHelpers_d_MOCK_RELEASE_NAME_CALVER: typeof MOCK_RELEASE_NAME_CALVER;
declare const testHelpers_d_MOCK_RELEASE_BRANCH_NAME_CALVER: typeof MOCK_RELEASE_BRANCH_NAME_CALVER;
declare const testHelpers_d_MOCK_RELEASE_CANDIDATE_TAG_NAME_CALVER: typeof MOCK_RELEASE_CANDIDATE_TAG_NAME_CALVER;
declare const testHelpers_d_MOCK_RELEASE_VERSION_TAG_NAME_CALVER: typeof MOCK_RELEASE_VERSION_TAG_NAME_CALVER;
declare const testHelpers_d_A_SEMVER_VERSION: typeof A_SEMVER_VERSION;
declare const testHelpers_d_MOCK_RELEASE_NAME_SEMVER: typeof MOCK_RELEASE_NAME_SEMVER;
declare const testHelpers_d_MOCK_RELEASE_BRANCH_NAME_SEMVER: typeof MOCK_RELEASE_BRANCH_NAME_SEMVER;
declare const testHelpers_d_MOCK_RELEASE_CANDIDATE_TAG_NAME_SEMVER: typeof MOCK_RELEASE_CANDIDATE_TAG_NAME_SEMVER;
declare const testHelpers_d_MOCK_RELEASE_VERSION_TAG_NAME_SEMVER: typeof MOCK_RELEASE_VERSION_TAG_NAME_SEMVER;
declare const testHelpers_d_createMockTag: typeof createMockTag;
declare const testHelpers_d_createMockCommit: typeof createMockCommit;
declare const testHelpers_d_mockUser: typeof mockUser;
declare const testHelpers_d_mockSemverProject: typeof mockSemverProject;
declare const testHelpers_d_mockCalverProject: typeof mockCalverProject;
declare const testHelpers_d_mockSearchCalver: typeof mockSearchCalver;
declare const testHelpers_d_mockSearchSemver: typeof mockSearchSemver;
declare const testHelpers_d_mockDefaultBranch: typeof mockDefaultBranch;
declare const testHelpers_d_mockNextGitInfoSemver: typeof mockNextGitInfoSemver;
declare const testHelpers_d_mockNextGitInfoCalver: typeof mockNextGitInfoCalver;
declare const testHelpers_d_mockTagParts: typeof mockTagParts;
declare const testHelpers_d_mockCtaMessage: typeof mockCtaMessage;
declare const testHelpers_d_mockBumpedTag: typeof mockBumpedTag;
declare const testHelpers_d_createMockRelease: typeof createMockRelease;
declare const testHelpers_d_mockReleaseCandidateCalver: typeof mockReleaseCandidateCalver;
declare const testHelpers_d_mockReleaseVersionCalver: typeof mockReleaseVersionCalver;
declare const testHelpers_d_mockReleaseCandidateSemver: typeof mockReleaseCandidateSemver;
declare const testHelpers_d_mockReleaseVersionSemver: typeof mockReleaseVersionSemver;
declare const testHelpers_d_createMockBranch: typeof createMockBranch;
declare const testHelpers_d_mockReleaseBranch: typeof mockReleaseBranch;
declare const testHelpers_d_createMockRecentCommit: typeof createMockRecentCommit;
declare const testHelpers_d_mockSelectedPatchCommit: typeof mockSelectedPatchCommit;
declare namespace testHelpers_d {
  export {
    testHelpers_d_mockUsername as mockUsername,
    testHelpers_d_mockEmail as mockEmail,
    testHelpers_d_mockOwner as mockOwner,
    testHelpers_d_mockRepo as mockRepo,
    testHelpers_d_A_CALVER_VERSION as A_CALVER_VERSION,
    testHelpers_d_MOCK_RELEASE_NAME_CALVER as MOCK_RELEASE_NAME_CALVER,
    testHelpers_d_MOCK_RELEASE_BRANCH_NAME_CALVER as MOCK_RELEASE_BRANCH_NAME_CALVER,
    testHelpers_d_MOCK_RELEASE_CANDIDATE_TAG_NAME_CALVER as MOCK_RELEASE_CANDIDATE_TAG_NAME_CALVER,
    testHelpers_d_MOCK_RELEASE_VERSION_TAG_NAME_CALVER as MOCK_RELEASE_VERSION_TAG_NAME_CALVER,
    testHelpers_d_A_SEMVER_VERSION as A_SEMVER_VERSION,
    testHelpers_d_MOCK_RELEASE_NAME_SEMVER as MOCK_RELEASE_NAME_SEMVER,
    testHelpers_d_MOCK_RELEASE_BRANCH_NAME_SEMVER as MOCK_RELEASE_BRANCH_NAME_SEMVER,
    testHelpers_d_MOCK_RELEASE_CANDIDATE_TAG_NAME_SEMVER as MOCK_RELEASE_CANDIDATE_TAG_NAME_SEMVER,
    testHelpers_d_MOCK_RELEASE_VERSION_TAG_NAME_SEMVER as MOCK_RELEASE_VERSION_TAG_NAME_SEMVER,
    testHelpers_d_createMockTag as createMockTag,
    testHelpers_d_createMockCommit as createMockCommit,
    testHelpers_d_mockUser as mockUser,
    testHelpers_d_mockSemverProject as mockSemverProject,
    testHelpers_d_mockCalverProject as mockCalverProject,
    testHelpers_d_mockSearchCalver as mockSearchCalver,
    testHelpers_d_mockSearchSemver as mockSearchSemver,
    testHelpers_d_mockDefaultBranch as mockDefaultBranch,
    testHelpers_d_mockNextGitInfoSemver as mockNextGitInfoSemver,
    testHelpers_d_mockNextGitInfoCalver as mockNextGitInfoCalver,
    testHelpers_d_mockTagParts as mockTagParts,
    testHelpers_d_mockCtaMessage as mockCtaMessage,
    testHelpers_d_mockBumpedTag as mockBumpedTag,
    testHelpers_d_createMockRelease as createMockRelease,
    testHelpers_d_mockReleaseCandidateCalver as mockReleaseCandidateCalver,
    testHelpers_d_mockReleaseVersionCalver as mockReleaseVersionCalver,
    testHelpers_d_mockReleaseCandidateSemver as mockReleaseCandidateSemver,
    testHelpers_d_mockReleaseVersionSemver as mockReleaseVersionSemver,
    testHelpers_d_createMockBranch as createMockBranch,
    testHelpers_d_mockReleaseBranch as mockReleaseBranch,
    testHelpers_d_createMockRecentCommit as createMockRecentCommit,
    testHelpers_d_mockSelectedPatchCommit as mockSelectedPatchCommit,
  };
}

declare const TEST_IDS: {
    info: {
        info: string;
        infoFeaturePlus: string;
    };
    createRc: {
        cta: string;
        semverSelect: string;
    };
    promoteRc: {
        mockedPromoteRcBody: string;
        notRcWarning: string;
        promoteRc: string;
        cta: string;
    };
    patch: {
        error: string;
        loading: string;
        notPrerelease: string;
        body: string;
    };
    form: {
        owner: {
            loading: string;
            select: string;
            error: string;
            empty: string;
        };
        repo: {
            loading: string;
            select: string;
            error: string;
            empty: string;
        };
        versioningStrategy: {
            radioGroup: string;
        };
    };
    components: {
        divider: string;
        noLatestRelease: string;
        circularProgress: string;
        responseStepListDialogContent: string;
        responseStepListItem: string;
        responseStepListItemIconSuccess: string;
        responseStepListItemIconFailure: string;
        responseStepListItemIconLink: string;
        responseStepListItemIconDefault: string;
        differ: {
            current: string;
            next: string;
            icons: {
                tag: string;
                branch: string;
                github: string;
                slack: string;
                versioning: string;
            };
        };
        linearProgressWithLabel: string;
    };
};

declare const testIds_d_TEST_IDS: typeof TEST_IDS;
declare namespace testIds_d {
  export {
    testIds_d_TEST_IDS as TEST_IDS,
  };
}

declare namespace testHelpers {
  export {
    stats_d as stats,
    testHelpers_d as testHelpers,
    testIds_d as testIds,
  };
}

declare const gitReleaseManagerPlugin: _backstage_core_plugin_api.BackstagePlugin<{
    root: _backstage_core_plugin_api.RouteRef<undefined>;
}, {}>;
declare const GitReleaseManagerPage: typeof GitReleaseManager;

/**
 * A Backstage plugin that helps you manage releases in git
 *
 * @packageDocumentation
 */

declare const internals: {
    components: typeof components;
    constants: typeof constants;
    helpers: typeof helpers;
    testHelpers: typeof testHelpers;
};

export { GitReleaseManagerPage, gitReleaseManagerApiRef, gitReleaseManagerPlugin, internals };
