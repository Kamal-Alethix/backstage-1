{"version":3,"file":"index.cjs.js","sources":["../src/types/api.ts","../src/CatalogClient.ts","../src/types/status.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CompoundEntityRef, Entity } from '@backstage/catalog-model';\n\n/**\n * This symbol can be used in place of a value when passed to filters in e.g.\n * {@link CatalogClient.getEntities}, to signify that you want to filter on the\n * presence of that key no matter what its value is.\n *\n * @public\n */\nexport const CATALOG_FILTER_EXISTS = Symbol.for(\n  // Random UUID to ensure no collisions\n  'CATALOG_FILTER_EXISTS_0e15b590c0b343a2bae3e787e84c2111',\n);\n\n/**\n * The request type for {@link CatalogClient.getEntities}.\n *\n * @public\n */\nexport interface GetEntitiesRequest {\n  /**\n   * If given, return only entities that match the given patterns.\n   *\n   * @remarks\n   *\n   * If multiple filter sets are given as an array, then there is effectively an\n   * OR between each filter set.\n   *\n   * Within one filter set, there is effectively an AND between the various\n   * keys.\n   *\n   * Within one key, if there are more than one value, then there is effectively\n   * an OR between them.\n   *\n   * Example: For an input of\n   *\n   * ```\n   * [\n   *   { kind: ['API', 'Component'] },\n   *   { 'metadata.name': 'a', 'metadata.namespace': 'b' }\n   * ]\n   * ```\n   *\n   * This effectively means\n   *\n   * ```\n   * (kind = EITHER 'API' OR 'Component')\n   * OR\n   * (metadata.name = 'a' AND metadata.namespace = 'b' )\n   * ```\n   *\n   * Each key is a dot separated path in each object.\n   *\n   * As a value you can also pass in the symbol `CATALOG_FILTER_EXISTS`\n   * (exported from this package), which means that you assert on the existence\n   * of that key, no matter what its value is.\n   */\n  filter?:\n    | Record<string, string | symbol | (string | symbol)[]>[]\n    | Record<string, string | symbol | (string | symbol)[]>\n    | undefined;\n  /**\n   * If given, return only the parts of each entity that match those dot\n   * separated paths in each object.\n   *\n   * @remarks\n   *\n   * Example: For an input of `['kind', 'metadata.annotations']`, then response\n   * objects will be shaped like\n   *\n   * ```\n   * {\n   *   \"kind\": \"Component\",\n   *   \"metadata\": {\n   *     \"annotations\": {\n   *       \"foo\": \"bar\"\n   *     }\n   *   }\n   * }\n   * ```\n   */\n  fields?: string[] | undefined;\n  /**\n   * If given, skips over the first N items in the result set.\n   */\n  offset?: number;\n  /**\n   * If given, returns at most N items from the result set.\n   */\n  limit?: number;\n  /**\n   * If given, skips over all items before that cursor as returned by a previous\n   * request.\n   */\n  after?: string;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntities}.\n *\n * @public\n */\nexport interface GetEntitiesResponse {\n  items: Entity[];\n}\n\n/**\n * The request type for {@link CatalogClient.getEntityAncestors}.\n *\n * @public\n */\nexport interface GetEntityAncestorsRequest {\n  entityRef: string;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntityAncestors}.\n *\n * @public\n */\nexport interface GetEntityAncestorsResponse {\n  rootEntityRef: string;\n  items: Array<{\n    entity: Entity;\n    parentEntityRefs: string[];\n  }>;\n}\n\n/**\n * The request type for {@link CatalogClient.getEntityFacets}.\n *\n * @public\n */\nexport interface GetEntityFacetsRequest {\n  /**\n   * If given, return only entities that match the given patterns.\n   *\n   * @remarks\n   *\n   * If multiple filter sets are given as an array, then there is effectively an\n   * OR between each filter set.\n   *\n   * Within one filter set, there is effectively an AND between the various\n   * keys.\n   *\n   * Within one key, if there are more than one value, then there is effectively\n   * an OR between them.\n   *\n   * Example: For an input of\n   *\n   * ```\n   * [\n   *   { kind: ['API', 'Component'] },\n   *   { 'metadata.name': 'a', 'metadata.namespace': 'b' }\n   * ]\n   * ```\n   *\n   * This effectively means\n   *\n   * ```\n   * (kind = EITHER 'API' OR 'Component')\n   * OR\n   * (metadata.name = 'a' AND metadata.namespace = 'b' )\n   * ```\n   *\n   * Each key is a dot separated path in each object.\n   *\n   * As a value you can also pass in the symbol `CATALOG_FILTER_EXISTS`\n   * (exported from this package), which means that you assert on the existence\n   * of that key, no matter what its value is.\n   */\n  filter?:\n    | Record<string, string | symbol | (string | symbol)[]>[]\n    | Record<string, string | symbol | (string | symbol)[]>\n    | undefined;\n  /**\n   * Dot separated paths for the facets to extract from each entity.\n   *\n   * @remarks\n   *\n   * Example: For an input of `['kind', 'metadata.annotations.backstage.io/orphan']`, then the\n   * response will be shaped like\n   *\n   * ```\n   * {\n   *   \"facets\": {\n   *     \"kind\": [\n   *       { \"key\": \"Component\", \"count\": 22 },\n   *       { \"key\": \"API\", \"count\": 13 }\n   *     ],\n   *     \"metadata.annotations.backstage.io/orphan\": [\n   *       { \"key\": \"true\", \"count\": 2 }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  facets: string[];\n}\n\n/**\n * The response type for {@link CatalogClient.getEntityFacets}.\n *\n * @public\n */\nexport interface GetEntityFacetsResponse {\n  /**\n   * The computed facets, one entry per facet in the request.\n   */\n  facets: Record<string, Array<{ value: string; count: number }>>;\n}\n\n/**\n * Options you can pass into a catalog request for additional information.\n *\n * @public\n */\nexport interface CatalogRequestOptions {\n  token?: string;\n}\n\n/**\n * Entity location for a specific entity.\n *\n * @public\n */\nexport type Location = {\n  id: string;\n  type: string;\n  target: string;\n};\n\n/**\n * The request type for {@link CatalogClient.addLocation}.\n *\n * @public\n */\nexport type AddLocationRequest = {\n  type?: string;\n  target: string;\n  dryRun?: boolean;\n};\n\n/**\n * The response type for {@link CatalogClient.addLocation}.\n *\n * @public\n */\nexport type AddLocationResponse = {\n  location: Location;\n  entities: Entity[];\n  // Only set in dryRun mode.\n  exists?: boolean;\n};\n\n/**\n * A client for interacting with the Backstage software catalog through its API.\n *\n * @public\n */\nexport interface CatalogApi {\n  /**\n   * Lists catalog entities.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntities(\n    request?: GetEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesResponse>;\n\n  /**\n   * Gets entity ancestor information, i.e. the hierarchy of parent entities\n   * whose processing resulted in a given entity appearing in the catalog.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntityAncestors(\n    request: GetEntityAncestorsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityAncestorsResponse>;\n\n  /**\n   * Gets a single entity from the catalog by its ref (kind, namespace, name)\n   * triplet.\n   *\n   * @param entityRef - A complete entity ref, either on string or compound form\n   * @param options - Additional options\n   * @returns The matching entity, or undefined if there was no entity with that ref\n   */\n  getEntityByRef(\n    entityRef: string | CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined>;\n\n  /**\n   * Removes a single entity from the catalog by entity UID.\n   *\n   * @param uid - An entity UID\n   * @param options - Additional options\n   */\n  removeEntityByUid(\n    uid: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Refreshes (marks for reprocessing) an entity in the catalog.\n   *\n   * @param entityRef - An entity ref on string form (e.g.\n   *        'component/default:my-component')\n   * @param options - Additional options\n   */\n  refreshEntity(\n    entityRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Gets a summary of field facets of entities in the catalog.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntityFacets(\n    request: GetEntityFacetsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityFacetsResponse>;\n\n  // Locations\n\n  /**\n   * Gets a registered location by its ID.\n   *\n   * @param id - A location ID\n   * @param options - Additional options\n   */\n  getLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined>;\n\n  /**\n   * Gets a registered location by its ref.\n   *\n   * @param locationRef - A location ref, e.g. \"url:https://github.com/...\"\n   * @param options - Additional options\n   */\n  getLocationByRef(\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined>;\n\n  /**\n   * Registers a new location.\n   *\n   * @param location - Request parameters\n   * @param options - Additional options\n   */\n  addLocation(\n    location: AddLocationRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<AddLocationResponse>;\n\n  /**\n   * Removes a registered Location by its ID.\n   *\n   * @param id - A location ID\n   * @param options - Additional options\n   */\n  removeLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Entity,\n  CompoundEntityRef,\n  parseEntityRef,\n  stringifyEntityRef,\n  stringifyLocationRef,\n} from '@backstage/catalog-model';\nimport { ResponseError } from '@backstage/errors';\nimport crossFetch from 'cross-fetch';\nimport {\n  CATALOG_FILTER_EXISTS,\n  AddLocationRequest,\n  AddLocationResponse,\n  CatalogApi,\n  GetEntitiesRequest,\n  GetEntitiesResponse,\n  CatalogRequestOptions,\n  GetEntityAncestorsRequest,\n  GetEntityAncestorsResponse,\n  Location,\n  GetEntityFacetsRequest,\n  GetEntityFacetsResponse,\n} from './types/api';\nimport { DiscoveryApi } from './types/discovery';\nimport { FetchApi } from './types/fetch';\n\n/**\n * A frontend and backend compatible client for communicating with the Backstage\n * software catalog.\n *\n * @public\n */\nexport class CatalogClient implements CatalogApi {\n  private readonly discoveryApi: DiscoveryApi;\n  private readonly fetchApi: FetchApi;\n\n  constructor(options: {\n    discoveryApi: { getBaseUrl(pluginId: string): Promise<string> };\n    fetchApi?: { fetch: typeof fetch };\n  }) {\n    this.discoveryApi = options.discoveryApi;\n    this.fetchApi = options.fetchApi || { fetch: crossFetch };\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntityAncestors}\n   */\n  async getEntityAncestors(\n    request: GetEntityAncestorsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityAncestorsResponse> {\n    const { kind, namespace, name } = parseEntityRef(request.entityRef);\n    return await this.requestRequired(\n      'GET',\n      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(\n        namespace,\n      )}/${encodeURIComponent(name)}/ancestry`,\n      options,\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getLocationById}\n   */\n  async getLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined> {\n    return await this.requestOptional(\n      'GET',\n      `/locations/${encodeURIComponent(id)}`,\n      options,\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntities}\n   */\n  async getEntities(\n    request?: GetEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesResponse> {\n    const { filter = [], fields = [], offset, limit, after } = request ?? {};\n    const params: string[] = [];\n\n    // filter param can occur multiple times, for example\n    // /api/catalog/entities?filter=metadata.name=wayback-search,kind=component&filter=metadata.name=www-artist,kind=component'\n    // the \"outer array\" defined by `filter` occurrences corresponds to \"anyOf\" filters\n    // the \"inner array\" defined within a `filter` param corresponds to \"allOf\" filters\n    for (const filterItem of [filter].flat()) {\n      const filterParts: string[] = [];\n      for (const [key, value] of Object.entries(filterItem)) {\n        for (const v of [value].flat()) {\n          if (v === CATALOG_FILTER_EXISTS) {\n            filterParts.push(encodeURIComponent(key));\n          } else if (typeof v === 'string') {\n            filterParts.push(\n              `${encodeURIComponent(key)}=${encodeURIComponent(v)}`,\n            );\n          }\n        }\n      }\n\n      if (filterParts.length) {\n        params.push(`filter=${filterParts.join(',')}`);\n      }\n    }\n\n    if (fields.length) {\n      params.push(`fields=${fields.map(encodeURIComponent).join(',')}`);\n    }\n\n    if (offset !== undefined) {\n      params.push(`offset=${offset}`);\n    }\n    if (limit !== undefined) {\n      params.push(`limit=${limit}`);\n    }\n    if (after !== undefined) {\n      params.push(`after=${encodeURIComponent(after)}`);\n    }\n\n    const query = params.length ? `?${params.join('&')}` : '';\n    const entities: Entity[] = await this.requestRequired(\n      'GET',\n      `/entities${query}`,\n      options,\n    );\n\n    const refCompare = (a: Entity, b: Entity) => {\n      // in case field filtering is used, these fields might not be part of the response\n      if (\n        a.metadata?.name === undefined ||\n        a.kind === undefined ||\n        b.metadata?.name === undefined ||\n        b.kind === undefined\n      ) {\n        return 0;\n      }\n\n      const aRef = stringifyEntityRef(a);\n      const bRef = stringifyEntityRef(b);\n      if (aRef < bRef) {\n        return -1;\n      }\n      if (aRef > bRef) {\n        return 1;\n      }\n      return 0;\n    };\n\n    return { items: entities.sort(refCompare) };\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntityByRef}\n   */\n  async getEntityByRef(\n    entityRef: string | CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined> {\n    const { kind, namespace, name } = parseEntityRef(entityRef);\n    return this.requestOptional(\n      'GET',\n      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(\n        namespace,\n      )}/${encodeURIComponent(name)}`,\n      options,\n    );\n  }\n\n  // NOTE(freben): When we deprecate getEntityByName from the interface, we may\n  // still want to leave this implementation in place for quite some time\n  // longer, to minimize the risk for breakages. Suggested date for removal:\n  // August 2022\n  /**\n   * @deprecated Use getEntityByRef instead\n   */\n  async getEntityByName(\n    compoundName: CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined> {\n    const { kind, namespace = 'default', name } = compoundName;\n    return this.requestOptional(\n      'GET',\n      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(\n        namespace,\n      )}/${encodeURIComponent(name)}`,\n      options,\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.refreshEntity}\n   */\n  async refreshEntity(entityRef: string, options?: CatalogRequestOptions) {\n    const response = await this.fetchApi.fetch(\n      `${await this.discoveryApi.getBaseUrl('catalog')}/refresh`,\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n        },\n        method: 'POST',\n        body: JSON.stringify({ entityRef }),\n      },\n    );\n\n    if (response.status !== 200) {\n      throw new Error(await response.text());\n    }\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntityFacets}\n   */\n  async getEntityFacets(\n    request: GetEntityFacetsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityFacetsResponse> {\n    const { filter = [], facets } = request;\n    const params: string[] = [];\n\n    // filter param can occur multiple times, for example\n    // /api/catalog/entities?filter=metadata.name=wayback-search,kind=component&filter=metadata.name=www-artist,kind=component'\n    // the \"outer array\" defined by `filter` occurrences corresponds to \"anyOf\" filters\n    // the \"inner array\" defined within a `filter` param corresponds to \"allOf\" filters\n    for (const filterItem of [filter].flat()) {\n      const filterParts: string[] = [];\n      for (const [key, value] of Object.entries(filterItem)) {\n        for (const v of [value].flat()) {\n          if (v === CATALOG_FILTER_EXISTS) {\n            filterParts.push(encodeURIComponent(key));\n          } else if (typeof v === 'string') {\n            filterParts.push(\n              `${encodeURIComponent(key)}=${encodeURIComponent(v)}`,\n            );\n          }\n        }\n      }\n\n      if (filterParts.length) {\n        params.push(`filter=${filterParts.join(',')}`);\n      }\n    }\n\n    for (const facet of facets) {\n      params.push(`facet=${encodeURIComponent(facet)}`);\n    }\n\n    const query = params.length ? `?${params.join('&')}` : '';\n    return await this.requestOptional('GET', `/entity-facets${query}`, options);\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.addLocation}\n   */\n  async addLocation(\n    { type = 'url', target, dryRun }: AddLocationRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<AddLocationResponse> {\n    const response = await this.fetchApi.fetch(\n      `${await this.discoveryApi.getBaseUrl('catalog')}/locations${\n        dryRun ? '?dryRun=true' : ''\n      }`,\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n        },\n        method: 'POST',\n        body: JSON.stringify({ type, target }),\n      },\n    );\n\n    if (response.status !== 201) {\n      throw new Error(await response.text());\n    }\n\n    const { location, entities, exists } = await response.json();\n\n    if (!location) {\n      throw new Error(`Location wasn't added: ${target}`);\n    }\n\n    return {\n      location,\n      entities,\n      exists,\n    };\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getLocationByRef}\n   */\n  async getLocationByRef(\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined> {\n    const all: { data: Location }[] = await this.requestRequired(\n      'GET',\n      '/locations',\n      options,\n    );\n    return all\n      .map(r => r.data)\n      .find(l => locationRef === stringifyLocationRef(l));\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.removeLocationById}\n   */\n  async removeLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    await this.requestIgnored(\n      'DELETE',\n      `/locations/${encodeURIComponent(id)}`,\n      options,\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.removeEntityByUid}\n   */\n  async removeEntityByUid(\n    uid: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    await this.requestIgnored(\n      'DELETE',\n      `/entities/by-uid/${encodeURIComponent(uid)}`,\n      options,\n    );\n  }\n\n  //\n  // Private methods\n  //\n\n  private async requestIgnored(\n    method: string,\n    path: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    const url = `${await this.discoveryApi.getBaseUrl('catalog')}${path}`;\n    const headers: Record<string, string> = options?.token\n      ? { Authorization: `Bearer ${options.token}` }\n      : {};\n    const response = await this.fetchApi.fetch(url, { method, headers });\n\n    if (!response.ok) {\n      throw await ResponseError.fromResponse(response);\n    }\n  }\n\n  private async requestRequired(\n    method: string,\n    path: string,\n    options?: CatalogRequestOptions,\n  ): Promise<any> {\n    const url = `${await this.discoveryApi.getBaseUrl('catalog')}${path}`;\n    const headers: Record<string, string> = options?.token\n      ? { Authorization: `Bearer ${options.token}` }\n      : {};\n    const response = await this.fetchApi.fetch(url, { method, headers });\n\n    if (!response.ok) {\n      throw await ResponseError.fromResponse(response);\n    }\n\n    return await response.json();\n  }\n\n  private async requestOptional(\n    method: string,\n    path: string,\n    options?: CatalogRequestOptions,\n  ): Promise<any | undefined> {\n    const url = `${await this.discoveryApi.getBaseUrl('catalog')}${path}`;\n    const headers: Record<string, string> = options?.token\n      ? { Authorization: `Bearer ${options.token}` }\n      : {};\n    const response = await this.fetchApi.fetch(url, { method, headers });\n\n    if (!response.ok) {\n      if (response.status === 404) {\n        return undefined;\n      }\n      throw await ResponseError.fromResponse(response);\n    }\n\n    return await response.json();\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The entity `status.items[].type` for the status of the processing engine in\n * regards to an entity.\n *\n * @public\n */\nexport const ENTITY_STATUS_CATALOG_PROCESSING_TYPE =\n  'backstage.io/catalog-processing';\n"],"names":["crossFetch","parseEntityRef","stringifyEntityRef","stringifyLocationRef","ResponseError"],"mappings":"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"}