{"version":3,"sources":["webpack://example-app/../node_modules/@graphiql/react/dist/Range.es.js","webpack://example-app/../node_modules/@graphiql/react/dist/hint.es.js","webpack://example-app/../node_modules/@graphiql/react/dist/onlineParser.es.js"],"names":[],"mappings":"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","file":"static/9394.a2ebc47b.chunk.js","sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match && match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whitespaces = match[0];\n        let pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\n__name(CharacterStream, \"CharacterStream\");\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\n__name(Range, \"Range\");\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\n__name(Position, \"Position\");\nexport { CharacterStream as C, Position as P, Range as R };\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"./show-hint.es.js\";\nimport { isCompositeType, getNamedType, TypeNameMetaFieldDef as TypeNameMetaFieldDef$1, SchemaMetaFieldDef as SchemaMetaFieldDef$1, TypeMetaFieldDef as TypeMetaFieldDef$1, GraphQLEnumType, GraphQLBoolean, isInterfaceType, isAbstractType, assertAbstractType, doTypesOverlap, isInputType, DirectiveLocation, visit, parse, isListType, isNonNullType, GraphQLInterfaceType, GraphQLObjectType, Kind, GraphQLInputObjectType, getNullableType, GraphQLList } from \"graphql\";\nimport { R as RuleKinds, C as CompletionItemKind, I as InsertTextFormat } from \"./index.es.js\";\nimport { C as CharacterStream, P as Position } from \"./Range.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport { S as SchemaMetaFieldDef, T as TypeMetaFieldDef, a as TypeNameMetaFieldDef } from \"./introspection.es.js\";\nimport \"react\";\nimport \"react-dom\";\nfunction getDefinitionState(tokenState) {\n  let definitionState;\n  forEachState(tokenState, (state) => {\n    switch (state.kind) {\n      case \"Query\":\n      case \"ShortQuery\":\n      case \"Mutation\":\n      case \"Subscription\":\n      case \"FragmentDefinition\":\n        definitionState = state;\n        break;\n    }\n  });\n  return definitionState;\n}\n__name(getDefinitionState, \"getDefinitionState\");\nfunction getFieldDef(schema, type, fieldName) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n    return SchemaMetaFieldDef;\n  }\n  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type) {\n    return TypeMetaFieldDef;\n  }\n  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (\"getFields\" in type) {\n    return type.getFields()[fieldName];\n  }\n  return null;\n}\n__name(getFieldDef, \"getFieldDef\");\nfunction forEachState(stack, fn) {\n  const reverseStateStack = [];\n  let state = stack;\n  while (state && state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n__name(forEachState, \"forEachState\");\nfunction objectValues(object) {\n  const keys = Object.keys(object);\n  const len = keys.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    values[i] = object[keys[i]];\n  }\n  return values;\n}\n__name(objectValues, \"objectValues\");\nfunction hintList(token, list) {\n  return filterAndSortList(list, normalizeText(token.string));\n}\n__name(hintList, \"hintList\");\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, (entry) => !entry.isDeprecated);\n  }\n  const byProximity = list.map((entry) => ({\n    proximity: getProximity(normalizeText(entry.label), text),\n    entry\n  }));\n  return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);\n}\n__name(filterAndSortList, \"filterAndSortList\");\nfunction filterNonEmpty(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n__name(filterNonEmpty, \"filterNonEmpty\");\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, \"\");\n}\n__name(normalizeText, \"normalizeText\");\nfunction getProximity(suggestion, text) {\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    proximity -= suggestion.length - text.length - 1;\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n__name(getProximity, \"getProximity\");\nfunction lexicalDistance(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n  return d[aLength][bLength];\n}\n__name(lexicalDistance, \"lexicalDistance\");\nconst SuggestionCommand = {\n  command: \"editor.action.triggerSuggest\",\n  title: \"Suggestions\"\n};\nconst collectFragmentDefs = /* @__PURE__ */ __name((op) => {\n  const externalFragments = [];\n  if (op) {\n    try {\n      visit(parse(op), {\n        FragmentDefinition(def) {\n          externalFragments.push(def);\n        }\n      });\n    } catch (_a) {\n      return [];\n    }\n  }\n  return externalFragments;\n}, \"collectFragmentDefs\");\nfunction getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {\n  var _a;\n  const opts = Object.assign(Object.assign({}, options), { schema });\n  const token = contextToken || getTokenAtPosition(queryText, cursor);\n  const state = token.state.kind === \"Invalid\" ? token.state.prevState : token.state;\n  if (!state) {\n    return [];\n  }\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo(schema, token.state);\n  if (kind === RuleKinds.DOCUMENT) {\n    return hintList(token, [\n      { label: \"query\", kind: CompletionItemKind.Function },\n      { label: \"mutation\", kind: CompletionItemKind.Function },\n      { label: \"subscription\", kind: CompletionItemKind.Function },\n      { label: \"fragment\", kind: CompletionItemKind.Function },\n      { label: \"{\", kind: CompletionItemKind.Constructor }\n    ]);\n  }\n  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n    return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n  }\n  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token, typeInfo, opts);\n  }\n  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {\n    const argDefs = typeInfo.argDefs;\n    if (argDefs) {\n      return hintList(token, argDefs.map((argDef) => {\n        var _a2;\n        return {\n          label: argDef.name,\n          insertText: argDef.name + \": \",\n          command: SuggestionCommand,\n          detail: String(argDef.type),\n          documentation: (_a2 = argDef.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: CompletionItemKind.Variable,\n          type: argDef.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = objectValues(typeInfo.objectFieldDefs);\n      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;\n      return hintList(token, objectFields.map((field) => {\n        var _a2;\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: completionKind,\n          type: field.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n  }\n  if (kind === RuleKinds.VARIABLE && step === 1) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const variableDefinitions = getVariableCompletions(queryText, schema, token);\n    return hintList(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n  }\n  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);\n  }\n  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));\n  }\n  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token, schema);\n  }\n  if (kind === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token, state, schema);\n  }\n  return [];\n}\n__name(getAutocompleteSuggestions, \"getAutocompleteSuggestions\");\nconst insertSuffix = ` {\n  $1\n}`;\nconst getInsertText = /* @__PURE__ */ __name((field) => {\n  const type = field.type;\n  if (isCompositeType(type)) {\n    return insertSuffix;\n  }\n  if (isListType(type) && isCompositeType(type.ofType)) {\n    return insertSuffix;\n  }\n  if (isNonNullType(type)) {\n    if (isCompositeType(type.ofType)) {\n      return insertSuffix;\n    }\n    if (isListType(type.ofType) && isCompositeType(type.ofType.ofType)) {\n      return insertSuffix;\n    }\n  }\n  return null;\n}, \"getInsertText\");\nfunction getSuggestionsForFieldNames(token, typeInfo, options) {\n  var _a;\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    let fields = [];\n    if (\"getFields\" in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef$1);\n    }\n    if (parentType === ((_a = options === null || options === void 0 ? void 0 : options.schema) === null || _a === void 0 ? void 0 : _a.getQueryType())) {\n      fields.push(SchemaMetaFieldDef$1, TypeMetaFieldDef$1);\n    }\n    return hintList(token, fields.map((field, index) => {\n      var _a2;\n      const suggestion = {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n        deprecated: Boolean(field.deprecationReason),\n        isDeprecated: Boolean(field.deprecationReason),\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind.Field,\n        type: field.type\n      };\n      const insertText = getInsertText(field);\n      if (insertText) {\n        suggestion.insertText = field.name + insertText;\n        suggestion.insertTextFormat = InsertTextFormat.Snippet;\n        suggestion.command = SuggestionCommand;\n      }\n      return suggestion;\n    }));\n  }\n  return [];\n}\n__name(getSuggestionsForFieldNames, \"getSuggestionsForFieldNames\");\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n  const namedInputType = getNamedType(typeInfo.inputType);\n  const queryVariables = getVariableCompletions(queryText, schema, token).filter((v) => v.detail === namedInputType.name);\n  if (namedInputType instanceof GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return hintList(token, values.map((value) => {\n      var _a;\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a = value.description) !== null && _a !== void 0 ? _a : void 0,\n        deprecated: Boolean(value.deprecationReason),\n        isDeprecated: Boolean(value.deprecationReason),\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind.EnumMember,\n        type: namedInputType\n      };\n    }).concat(queryVariables));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList(token, queryVariables.concat([\n      {\n        label: \"true\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not false.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      },\n      {\n        label: \"false\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not true.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      }\n    ]));\n  }\n  return queryVariables;\n}\n__name(getSuggestionsForInputValues, \"getSuggestionsForInputValues\");\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n  if (tokenState.needsSeperator) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n  const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);\n  const inlineInterfaces = /* @__PURE__ */ new Set();\n  runOnlineParser(documentText, (_, state) => {\n    var _a, _b, _c, _d, _e;\n    if (state.name) {\n      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {\n        inlineInterfaces.add(state.name);\n      }\n      if (state.kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n        if (typeInfo.interfaceDef) {\n          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [\n            ...interfaceConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        } else if (typeInfo.objectTypeDef) {\n          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [\n            ...objectTypeConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        }\n      }\n    }\n  });\n  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n  const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);\n  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name) => ({ name }))).filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));\n  return hintList(token, possibleInterfaces.map((type) => {\n    const result = {\n      label: type.name,\n      kind: CompletionItemKind.Interface,\n      type\n    };\n    if (type === null || type === void 0 ? void 0 : type.description) {\n      result.documentation = type.description;\n    }\n    return result;\n  }));\n}\n__name(getSuggestionsForImplements, \"getSuggestionsForImplements\");\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n  let possibleTypes;\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      const abstractType = assertAbstractType(typeInfo.parentType);\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = /* @__PURE__ */ Object.create(null);\n      possibleObjTypes.forEach((type) => {\n        type.getInterfaces().forEach((iface) => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n  return hintList(token, possibleTypes.map((type) => {\n    const namedType = getNamedType(type);\n    return {\n      label: String(type),\n      documentation: namedType && namedType.description || \"\",\n      kind: CompletionItemKind.Field\n    };\n  }));\n}\n__name(getSuggestionsForFragmentTypeConditions, \"getSuggestionsForFragmentTypeConditions\");\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n  if (!queryText) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token.state);\n  const fragments = getFragmentDefinitions(queryText);\n  if (fragmentDefs && fragmentDefs.length > 0) {\n    fragments.push(...fragmentDefs);\n  }\n  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return hintList(token, relevantFrags.map((frag) => ({\n    label: frag.name.value,\n    detail: String(typeMap[frag.typeCondition.name.value]),\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n    kind: CompletionItemKind.Field,\n    type: typeMap[frag.typeCondition.name.value]\n  })));\n}\n__name(getSuggestionsForFragmentSpread, \"getSuggestionsForFragmentSpread\");\nconst getParentDefinition = /* @__PURE__ */ __name((state, kind) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n  if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n    return state.prevState;\n  }\n  if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n    return state.prevState.prevState;\n  }\n  if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n    return state.prevState.prevState.prevState;\n  }\n  if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n}, \"getParentDefinition\");\nfunction getVariableCompletions(queryText, schema, token) {\n  let variableName = null;\n  let variableType;\n  const definitions = /* @__PURE__ */ Object.create({});\n  runOnlineParser(queryText, (_, state) => {\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {\n      variableName = state.name;\n    }\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {\n      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n      }\n    }\n    if (variableName && variableType) {\n      if (!definitions[variableName]) {\n        definitions[variableName] = {\n          detail: variableType.toString(),\n          insertText: token.string === \"$\" ? variableName : \"$\" + variableName,\n          label: variableName,\n          type: variableType,\n          kind: CompletionItemKind.Variable\n        };\n        variableName = null;\n        variableType = null;\n      }\n    }\n  });\n  return objectValues(definitions);\n}\n__name(getVariableCompletions, \"getVariableCompletions\");\nfunction getFragmentDefinitions(queryText) {\n  const fragmentDefs = [];\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: Kind.NAME,\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: Kind.NAME,\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\n__name(getFragmentDefinitions, \"getFragmentDefinitions\");\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList(token, inputTypes.map((type) => ({\n    label: type.name,\n    documentation: type.description,\n    kind: CompletionItemKind.Variable\n  })));\n}\n__name(getSuggestionsForVariableDefinition, \"getSuggestionsForVariableDefinition\");\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n  if (state.prevState && state.prevState.kind) {\n    const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));\n    return hintList(token, directives.map((directive) => ({\n      label: directive.name,\n      documentation: directive.description || \"\",\n      kind: CompletionItemKind.Function\n    })));\n  }\n  return [];\n}\n__name(getSuggestionsForDirective, \"getSuggestionsForDirective\");\nfunction getTokenAtPosition(queryText, cursor) {\n  let styleAtCursor = null;\n  let stateAtCursor = null;\n  let stringAtCursor = null;\n  const token = runOnlineParser(queryText, (stream, state, style, index) => {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return \"BREAK\";\n      }\n    }\n  });\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\n__name(getTokenAtPosition, \"getTokenAtPosition\");\nfunction runOnlineParser(queryText, callback) {\n  const lines = queryText.split(\"\\n\");\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = \"\";\n  let stream = new CharacterStream(\"\");\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code = callback(stream, state, style, i);\n      if (code === \"BREAK\") {\n        break;\n      }\n    }\n    callback(stream, state, style, i);\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style\n  };\n}\n__name(runOnlineParser, \"runOnlineParser\");\nfunction canUseDirective(state, directive) {\n  if (!state || !state.kind) {\n    return false;\n  }\n  const kind = state.kind;\n  const locations = directive.locations;\n  switch (kind) {\n    case RuleKinds.QUERY:\n      return locations.indexOf(DirectiveLocation.QUERY) !== -1;\n    case RuleKinds.MUTATION:\n      return locations.indexOf(DirectiveLocation.MUTATION) !== -1;\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf(DirectiveLocation.FIELD) !== -1;\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf(DirectiveLocation.SCALAR) !== -1;\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf(DirectiveLocation.OBJECT) !== -1;\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf(DirectiveLocation.UNION) !== -1;\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf(DirectiveLocation.ENUM) !== -1;\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;\n    case RuleKinds.INPUT_VALUE_DEF:\n      const prevStateKind = state.prevState && state.prevState.kind;\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1;\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;\n      }\n  }\n  return false;\n}\n__name(canUseDirective, \"canUseDirective\");\nfunction getTypeInfo(schema, tokenState) {\n  let argDef;\n  let argDefs;\n  let directiveDef;\n  let enumValue;\n  let fieldDef;\n  let inputType;\n  let objectTypeDef;\n  let objectFieldDefs;\n  let parentType;\n  let type;\n  let interfaceDef;\n  forEachState(tokenState, (state) => {\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case \"ShortQuery\":\n        type = schema.getQueryType();\n        break;\n      case RuleKinds.MUTATION:\n        type = schema.getMutationType();\n        break;\n      case RuleKinds.SUBSCRIPTION:\n        type = schema.getSubscriptionType();\n        break;\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n        break;\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD: {\n        if (!type || !state.name) {\n          fieldDef = null;\n        } else {\n          fieldDef = parentType ? getFieldDef(schema, parentType, state.name) : null;\n          type = fieldDef ? fieldDef.type : null;\n        }\n        break;\n      }\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type);\n        break;\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case RuleKinds.INTERFACE_DEF:\n        if (state.name) {\n          objectTypeDef = null;\n          interfaceDef = new GraphQLInterfaceType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.OBJECT_TYPE_DEF:\n        if (state.name) {\n          interfaceDef = null;\n          objectTypeDef = new GraphQLObjectType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.ARGUMENTS: {\n        if (!state.prevState) {\n          argDefs = null;\n        } else {\n          switch (state.prevState.kind) {\n            case RuleKinds.FIELD:\n              argDefs = fieldDef && fieldDef.args;\n              break;\n            case RuleKinds.DIRECTIVE:\n              argDefs = directiveDef && directiveDef.args;\n              break;\n            case RuleKinds.ALIASED_FIELD: {\n              const name = state.prevState && state.prevState.name;\n              if (!name) {\n                argDefs = null;\n                break;\n              }\n              const field = parentType ? getFieldDef(schema, parentType, name) : null;\n              if (!field) {\n                argDefs = null;\n                break;\n              }\n              argDefs = field.args;\n              break;\n            }\n            default:\n              argDefs = null;\n              break;\n          }\n        }\n        break;\n      }\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (let i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n        inputType = argDef && argDef.type;\n        break;\n      case RuleKinds.ENUM_VALUE:\n        const enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;\n        break;\n      case RuleKinds.LIST_VALUE:\n        const nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n      case RuleKinds.OBJECT_VALUE:\n        const objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case RuleKinds.OBJECT_FIELD:\n        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField && objectField.type;\n        break;\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n        break;\n    }\n  });\n  return {\n    argDef,\n    argDefs,\n    directiveDef,\n    enumValue,\n    fieldDef,\n    inputType,\n    objectFieldDefs,\n    parentType,\n    type,\n    interfaceDef,\n    objectTypeDef\n  };\n}\n__name(getTypeInfo, \"getTypeInfo\");\nCodeMirror.registerHelper(\"hint\", \"graphql\", (editor, options) => {\n  const schema = options.schema;\n  if (!schema) {\n    return;\n  }\n  const cur = editor.getCursor();\n  const token = editor.getTokenAt(cur);\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  const position = new Position(cur.line, tokenStart);\n  const rawResults = getAutocompleteSuggestions(schema, editor.getValue(), position, token, options.externalFragments);\n  const results = {\n    list: rawResults.map((item) => ({\n      text: item.label,\n      type: item.type,\n      description: item.documentation,\n      isDeprecated: item.isDeprecated,\n      deprecationReason: item.deprecationReason\n    })),\n    from: { line: cur.line, ch: tokenStart },\n    to: { line: cur.line, ch: token.end }\n  };\n  if (results && results.list && results.list.length > 0) {\n    results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n    results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n    CodeMirror.signal(editor, \"hasCompletion\", editor, results, token);\n  }\n  return results;\n});\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\nfunction onlineParser(options = {\n  eatWhitespace: (stream) => stream.eatWhile(isIgnored),\n  lexRules: LexRules,\n  parseRules: ParseRules,\n  editorConfig: {}\n}) {\n  return {\n    startState() {\n      const initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n__name(onlineParser, \"onlineParser\");\nfunction getToken(stream, state, options) {\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n  if (stream.sol()) {\n    const tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n  const token = lex(lexRules, stream);\n  if (!token) {\n    const matchedSomething = stream.match(/\\S+/);\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n  const backupState = assign({}, state);\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      const levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n  while (state.rule) {\n    let expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n    if (state.needsSeperator) {\n      expected = expected && (expected === null || expected === void 0 ? void 0 : expected.separator);\n    }\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n__name(getToken, \"getToken\");\nfunction assign(to, from) {\n  const keys = Object.keys(from);\n  for (let i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n__name(assign, \"assign\");\nconst SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n}\n__name(pushRule, \"pushRule\");\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n}\n__name(popRule, \"popRule\");\nfunction advanceRule(state, successful) {\n  if (isList(state) && state.rule) {\n    const step = state.rule[state.step];\n    if (step.separator) {\n      const separator = step.separator;\n      state.needsSeperator = !state.needsSeperator;\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    }\n    if (successful) {\n      return;\n    }\n  }\n  state.needsSeperator = false;\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    if (state.rule) {\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n__name(advanceRule, \"advanceRule\");\nfunction isList(state) {\n  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n__name(isList, \"isList\");\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n__name(unsuccessful, \"unsuccessful\");\nfunction lex(lexRules, stream) {\n  const kinds = Object.keys(lexRules);\n  for (let i = 0; i < kinds.length; i++) {\n    const match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n__name(lex, \"lex\");\nexport { onlineParser as o };\n"],"sourceRoot":""}