{"version":3,"sources":["webpack://example-app/../node_modules/@graphiql/react/dist/javascript.es.js"],"names":[],"mappings":"uLAAI,GAAY,OAAO,eACnB,EAAS,CAAC,EAAQ,KAAU,GAAU,EAAQ,OAAQ,CAAE,SAAO,aAAc,EAAK,CAAC,EAEvF,YAA0B,EAAG,GAAG,CAC9B,UAAE,QAAQ,SAAS,EAAG,CACpB,GAAK,MAAO,IAAM,UAAY,CAAC,MAAM,QAAQ,CAAC,GAAK,OAAO,KAAK,CAAC,EAAE,QAAQ,SAAS,EAAG,CACpF,GAAI,IAAM,WAAa,CAAE,KAAK,IAAI,CAChC,GAAI,GAAI,OAAO,yBAAyB,EAAG,CAAC,EAC5C,OAAO,eAAe,EAAG,EAAG,EAAE,IAAM,EAAI,CACtC,WAAY,GACZ,IAAK,UAAW,CACd,MAAO,GAAE,EACX,CACF,CAAC,CACH,CACF,CAAC,CACH,CAAC,EACM,OAAO,OAAO,CAAC,CACxB,CACA,EAAO,GAAkB,kBAAkB,EAC3C,GAAI,IAAe,CAAE,QAAS,CAAC,CAAE,EAChC,UAAS,EAAQ,GAAS,CACxB,UAAS,EAAK,CACb,EAAI,YAAkB,CACxB,GAAG,SAAS,EAAY,CACtB,EAAW,WAAW,aAAc,SAAS,EAAQ,EAAc,CACjE,GAAI,GAAa,EAAO,WACpB,GAAkB,EAAa,gBAC/B,GAAa,EAAa,OAC1B,EAAW,EAAa,MAAQ,GAChC,GAAa,EAAa,aAAe,GACzC,EAAO,EAAa,WACpB,GAAS,EAAa,gBAAkB,mBACxC,GAAW,UAAW,CACxB,WAAY,EAAO,CACjB,MAAO,CAAE,KAAM,EAAO,MAAO,SAAU,CACzC,CACA,EAAO,EAAI,IAAI,EACf,GAAI,GAAI,EAAG,WAAW,EAAG,EAAI,EAAG,WAAW,EAAG,EAAI,EAAG,WAAW,EAAG,EAAI,EAAG,WAAW,EACjF,EAAW,EAAG,UAAU,EAAG,EAAO,CAAE,KAAM,OAAQ,MAAO,MAAO,EACpE,MAAO,CACL,GAAM,EAAG,IAAI,EACb,MAAS,EACT,KAAQ,EACR,KAAQ,EACR,GAAM,EACN,IAAO,EACP,QAAW,EACX,OAAU,EACV,MAAS,EACT,SAAY,EACZ,IAAO,EAAG,KAAK,EACf,OAAU,EACV,KAAQ,EACR,MAAS,EACT,SAAY,EAAG,UAAU,EACzB,IAAO,EAAG,KAAK,EACf,MAAS,EAAG,KAAK,EACjB,IAAO,EAAG,KAAK,EACf,SAAY,EAAG,UAAU,EACzB,MAAS,EAAG,OAAO,EACnB,IAAO,EAAG,KAAK,EACf,OAAU,EAAG,QAAQ,EACrB,KAAQ,EAAG,MAAM,EACjB,QAAW,EAAG,SAAS,EACvB,GAAM,EACN,OAAU,EACV,WAAc,EACd,KAAQ,EACR,MAAS,EACT,KAAQ,EACR,UAAa,EACb,IAAO,EACP,SAAY,EACZ,KAAQ,EAAG,MAAM,EACjB,MAAS,EAAG,OAAO,EACnB,MAAS,EAAG,MAAM,EAClB,MAAS,EACT,OAAU,EAAG,QAAQ,EACrB,OAAU,EAAG,QAAQ,EACrB,QAAW,EACX,MAAS,CACX,CACF,EAAE,EACE,GAAiB,oBACjB,GAAkB,wFACtB,YAAoB,EAAQ,CAE1B,OADI,GAAU,GAAO,EAAM,EAAQ,GAC3B,GAAO,EAAO,KAAK,IAAM,MAAM,CACrC,GAAI,CAAC,EAAS,CACZ,GAAI,GAAQ,KAAO,CAAC,EAClB,OACE,GAAQ,IACV,EAAQ,GACD,GAAS,GAAQ,KACxB,GAAQ,GACZ,CACA,EAAU,CAAC,GAAW,GAAQ,IAChC,CACF,CACA,EAAO,GAAY,YAAY,EAC/B,GAAI,GAAM,GACV,WAAa,EAAI,EAAO,EAAO,CAC7B,SAAO,EACP,GAAU,EACH,CACT,CACA,EAAO,EAAK,KAAK,EACjB,WAAmB,EAAQ,EAAO,CAChC,GAAI,GAAK,EAAO,KAAK,EACrB,GAAI,GAAM,KAAO,GAAM,IACrB,SAAM,SAAW,GAAY,CAAE,EACxB,EAAM,SAAS,EAAQ,CAAK,EAC9B,GAAI,GAAM,KAAO,EAAO,MAAM,gCAAgC,EACnE,MAAO,GAAI,SAAU,QAAQ,EACxB,GAAI,GAAM,KAAO,EAAO,MAAM,IAAI,EACvC,MAAO,GAAI,SAAU,MAAM,EACtB,GAAI,qBAAqB,KAAK,CAAE,EACrC,MAAO,GAAI,CAAE,EACR,GAAI,GAAM,KAAO,EAAO,IAAI,GAAG,EACpC,MAAO,GAAI,KAAM,UAAU,EACtB,GAAI,GAAM,KAAO,EAAO,MAAM,uCAAuC,EAC1E,MAAO,GAAI,SAAU,QAAQ,EACxB,GAAI,KAAK,KAAK,CAAE,EACrB,SAAO,MAAM,kDAAkD,EACxD,EAAI,SAAU,QAAQ,EACxB,GAAI,GAAM,IACf,MAAI,GAAO,IAAI,GAAG,EAChB,GAAM,SAAW,EACV,EAAa,EAAQ,CAAK,GACxB,EAAO,IAAI,GAAG,EACvB,GAAO,UAAU,EACV,EAAI,UAAW,SAAS,GACtB,GAAkB,EAAQ,EAAO,CAAC,EAC3C,IAAW,CAAM,EACjB,EAAO,MAAM,mCAAmC,EACzC,EAAI,SAAU,UAAU,GAE/B,GAAO,IAAI,GAAG,EACP,EAAI,WAAY,WAAY,EAAO,QAAQ,CAAC,GAEhD,GAAI,GAAM,IACf,SAAM,SAAW,EACV,EAAW,EAAQ,CAAK,EAC1B,GAAI,GAAM,KAAO,EAAO,KAAK,GAAK,IACvC,SAAO,UAAU,EACV,EAAI,OAAQ,MAAM,EACpB,GAAI,GAAM,KAAO,EAAO,SAAS,EAAM,EAC5C,MAAO,GAAI,WAAY,UAAU,EAC5B,GAAI,GAAM,KAAO,EAAO,MAAM,KAAK,GAAK,GAAM,KAAO,EAAO,MAAM,IAAI,GAAK,CAAC,KAAK,KAAK,EAAO,OAAO,MAAM,EAAG,EAAO,KAAK,CAAC,EAC/H,SAAO,UAAU,EACV,EAAI,UAAW,SAAS,EAC1B,GAAI,GAAe,KAAK,CAAE,EAW/B,MAVI,IAAM,KAAO,CAAC,EAAM,SAAW,EAAM,QAAQ,MAAQ,MACvD,CAAI,EAAO,IAAI,GAAG,EACZ,IAAM,KAAO,GAAM,MACrB,EAAO,IAAI,GAAG,EACP,cAAc,KAAK,CAAE,GAC9B,GAAO,IAAI,CAAE,EACT,GAAM,KACR,EAAO,IAAI,CAAE,IAGf,GAAM,KAAO,EAAO,IAAI,GAAG,EACtB,EAAI,GAAG,EACT,EAAI,WAAY,WAAY,EAAO,QAAQ,CAAC,EAC9C,GAAI,GAAO,KAAK,CAAE,EAAG,CAC1B,EAAO,SAAS,EAAM,EACtB,GAAI,GAAO,EAAO,QAAQ,EAC1B,GAAI,EAAM,UAAY,IAAK,CACzB,GAAI,GAAS,qBAAqB,CAAI,EAAG,CACvC,GAAI,GAAK,GAAS,GAClB,MAAO,GAAI,EAAG,KAAM,EAAG,MAAO,CAAI,CACpC,CACA,GAAI,GAAQ,SAAW,EAAO,MAAM,2CAA4C,EAAK,EACnF,MAAO,GAAI,QAAS,UAAW,CAAI,CACvC,CACA,MAAO,GAAI,WAAY,WAAY,CAAI,CACzC,CACF,CACA,EAAO,EAAW,WAAW,EAC7B,YAAqB,EAAO,CAC1B,MAAO,UAAS,EAAQ,EAAO,CAC7B,GAAI,GAAU,GAAO,EACrB,GAAI,IAAc,EAAO,KAAK,GAAK,KAAO,EAAO,MAAM,EAAe,EACpE,SAAM,SAAW,EACV,EAAI,iBAAkB,MAAM,EAErC,KAAQ,GAAO,EAAO,KAAK,IAAM,MAC3B,KAAQ,GAAS,CAAC,IAEtB,EAAU,CAAC,GAAW,GAAQ,KAEhC,MAAK,IACH,GAAM,SAAW,GACZ,EAAI,SAAU,QAAQ,CAC/B,CACF,CACA,EAAO,GAAa,aAAa,EACjC,WAAsB,EAAQ,EAAO,CAEnC,OADI,GAAW,GAAO,EACf,EAAK,EAAO,KAAK,GAAG,CACzB,GAAI,GAAM,KAAO,EAAU,CACzB,EAAM,SAAW,EACjB,KACF,CACA,EAAW,GAAM,GACnB,CACA,MAAO,GAAI,UAAW,SAAS,CACjC,CACA,EAAO,EAAc,cAAc,EACnC,WAAoB,EAAQ,EAAO,CAEjC,OADI,GAAU,GAAO,EACb,GAAO,EAAO,KAAK,IAAM,MAAM,CACrC,GAAI,CAAC,GAAY,IAAQ,KAAO,GAAQ,KAAO,EAAO,IAAI,GAAG,GAAI,CAC/D,EAAM,SAAW,EACjB,KACF,CACA,EAAU,CAAC,GAAW,GAAQ,IAChC,CACA,MAAO,GAAI,QAAS,WAAY,EAAO,QAAQ,CAAC,CAClD,CACA,EAAO,EAAY,YAAY,EAC/B,GAAI,IAAW,SACf,YAAsB,EAAQ,EAAO,CAC/B,EAAM,YACR,GAAM,WAAa,MACrB,GAAI,GAAQ,EAAO,OAAO,QAAQ,KAAM,EAAO,KAAK,EACpD,GAAI,IAAQ,GAEZ,IAAI,EAAM,CACR,GAAI,GAAI,6CAA6C,KAAK,EAAO,OAAO,MAAM,EAAO,MAAO,CAAK,CAAC,EAC9F,GACF,GAAQ,EAAE,MACd,CAEA,OADI,GAAQ,EAAG,EAAe,GACrB,EAAM,EAAQ,EAAG,GAAO,EAAG,EAAE,EAAK,CACzC,GAAI,GAAK,EAAO,OAAO,OAAO,CAAG,EAC7B,EAAU,GAAS,QAAQ,CAAE,EACjC,GAAI,GAAW,GAAK,EAAU,EAAG,CAC/B,GAAI,CAAC,EAAO,CACV,EAAE,EACF,KACF,CACA,GAAI,EAAE,GAAS,EAAG,CACZ,GAAM,KACR,GAAe,IACjB,KACF,CACF,SAAW,GAAW,GAAK,EAAU,EACnC,EAAE,UACO,GAAO,KAAK,CAAE,EACvB,EAAe,WACN,UAAU,KAAK,CAAE,EAC1B,MAAS,EAAE,EAAK,CACd,GAAI,GAAO,EACT,OACF,GAAI,IAAO,EAAO,OAAO,OAAO,EAAM,CAAC,EACvC,GAAI,IAAQ,GAAM,EAAO,OAAO,OAAO,EAAM,CAAC,GAAK,KAAM,CACvD,IACA,KACF,CACF,SACS,GAAgB,CAAC,EAAO,CACjC,EAAE,EACF,KACF,CACF,CACI,GAAgB,CAAC,GACnB,GAAM,WAAa,GACvB,CACA,EAAO,GAAc,cAAc,EACnC,GAAI,IAAc,CAChB,KAAQ,GACR,OAAU,GACV,SAAY,GACZ,OAAU,GACV,OAAU,GACV,KAAQ,GACR,OAAU,GACV,iBAAkB,EACpB,EACA,YAAmB,EAAU,EAAQ,EAAO,EAAO,EAAM,EAAM,CAC7D,KAAK,SAAW,EAChB,KAAK,OAAS,EACd,KAAK,KAAO,EACZ,KAAK,KAAO,EACZ,KAAK,KAAO,EACR,GAAS,MACX,MAAK,MAAQ,EACjB,CACA,EAAO,GAAW,WAAW,EAC7B,YAAiB,EAAO,EAAS,CAC/B,GAAI,CAAC,GACH,MAAO,GACT,OAAS,GAAI,EAAM,UAAW,EAAG,EAAI,EAAE,KACrC,GAAI,EAAE,MAAQ,EACZ,MAAO,GACX,OAAS,GAAM,EAAM,QAAS,EAAK,EAAM,EAAI,KAC3C,OAAS,GAAI,EAAI,KAAM,EAAG,EAAI,EAAE,KAC9B,GAAI,EAAE,MAAQ,EACZ,MAAO,EAEf,CACA,EAAO,GAAS,SAAS,EACzB,YAAiB,EAAO,EAAO,EAAO,EAAU,EAAQ,CACtD,GAAI,GAAK,EAAM,GAOf,IANA,EAAG,MAAQ,EACX,EAAG,OAAS,EACZ,EAAG,OAAS,KAAM,EAAG,GAAK,EAC1B,EAAG,MAAQ,EACN,EAAM,QAAQ,eAAe,OAAO,GACvC,GAAM,QAAQ,MAAQ,MACX,CACX,GAAI,GAAa,EAAG,OAAS,EAAG,IAAI,EAAI,EAAW,EAAa,EAChE,GAAI,EAAW,EAAO,CAAQ,EAAG,CAC/B,KAAO,EAAG,QAAU,EAAG,EAAG,OAAS,GAAG,KACpC,EAAG,IAAI,EAAE,EACX,MAAI,GAAG,OACE,EAAG,OACR,GAAS,YAAc,GAAQ,EAAO,CAAQ,EACzC,aACF,CACT,CACF,CACF,CACA,EAAO,GAAS,SAAS,EACzB,GAAI,GAAK,CAAE,MAAO,KAAM,OAAQ,KAAM,OAAQ,KAAM,GAAI,IAAK,EAC7D,YAAgB,CACd,OAAS,GAAI,UAAU,OAAS,EAAG,GAAK,EAAG,IACzC,EAAG,GAAG,KAAK,UAAU,EAAE,CAC3B,CACA,EAAO,EAAM,MAAM,EACnB,YAAgB,CACd,SAAK,MAAM,KAAM,SAAS,EACnB,EACT,CACA,EAAO,EAAM,MAAM,EACnB,YAAgB,EAAM,EAAM,CAC1B,OAAS,GAAI,EAAM,EAAG,EAAI,EAAE,KAC1B,GAAI,EAAE,MAAQ,EACZ,MAAO,GACX,MAAO,EACT,CACA,EAAO,GAAQ,QAAQ,EACvB,WAAkB,EAAS,CACzB,GAAI,GAAQ,EAAG,MAEf,GADA,EAAG,OAAS,MACR,EAAC,GAEL,IAAI,EAAM,SACR,GAAI,EAAM,QAAQ,MAAQ,OAAS,EAAM,SAAW,EAAM,QAAQ,MAAO,CACvE,GAAI,GAAa,GAAkB,EAAS,EAAM,OAAO,EACzD,GAAI,GAAc,KAAM,CACtB,EAAM,QAAU,EAChB,MACF,CACF,SAAW,CAAC,GAAO,EAAS,EAAM,SAAS,EAAG,CAC5C,EAAM,UAAY,GAAI,GAAI,EAAS,EAAM,SAAS,EAClD,MACF,EAEE,EAAa,YAAc,CAAC,GAAO,EAAS,EAAM,UAAU,GAC9D,GAAM,WAAa,GAAI,GAAI,EAAS,EAAM,UAAU,GACxD,CACA,EAAO,EAAU,UAAU,EAC3B,YAA2B,EAAS,EAAS,CAC3C,GAAK,EAEE,GAAI,EAAQ,MAAO,CACxB,GAAI,GAAQ,GAAkB,EAAS,EAAQ,IAAI,EACnD,MAAK,GAED,GAAS,EAAQ,KACZ,EACF,GAAI,GAAQ,EAAO,EAAQ,KAAM,EAAI,EAHnC,IAIX,KAAO,OAAI,IAAO,EAAS,EAAQ,IAAI,EAC9B,EAEA,GAAI,GAAQ,EAAQ,KAAM,GAAI,GAAI,EAAS,EAAQ,IAAI,EAAG,EAAK,MAXtE,OAAO,KAaX,CACA,EAAO,GAAmB,mBAAmB,EAC7C,YAAoB,EAAM,CACxB,MAAO,IAAQ,UAAY,GAAQ,WAAa,GAAQ,aAAe,GAAQ,YAAc,GAAQ,UACvG,CACA,EAAO,GAAY,YAAY,EAC/B,WAAiB,EAAM,EAAM,EAAQ,CACnC,KAAK,KAAO,EACZ,KAAK,KAAO,EACZ,KAAK,MAAQ,CACf,CACA,EAAO,EAAS,SAAS,EACzB,WAAa,EAAM,EAAM,CACvB,KAAK,KAAO,EACZ,KAAK,KAAO,CACd,CACA,EAAO,EAAK,KAAK,EACjB,GAAI,IAAc,GAAI,GAAI,OAAQ,GAAI,GAAI,YAAa,IAAI,CAAC,EAC5D,YAAuB,CACrB,EAAG,MAAM,QAAU,GAAI,GAAQ,EAAG,MAAM,QAAS,EAAG,MAAM,UAAW,EAAK,EAC1E,EAAG,MAAM,UAAY,EACvB,CACA,EAAO,EAAa,aAAa,EACjC,aAA4B,CAC1B,EAAG,MAAM,QAAU,GAAI,GAAQ,EAAG,MAAM,QAAS,EAAG,MAAM,UAAW,EAAI,EACzE,EAAG,MAAM,UAAY,IACvB,CACA,EAAO,GAAkB,kBAAkB,EAC3C,EAAY,IAAM,GAAiB,IAAM,GACzC,YAAsB,CACpB,EAAG,MAAM,UAAY,EAAG,MAAM,QAAQ,KACtC,EAAG,MAAM,QAAU,EAAG,MAAM,QAAQ,IACtC,CACA,EAAO,EAAY,YAAY,EAC/B,EAAW,IAAM,GACjB,WAAiB,EAAO,EAAM,CAC5B,GAAI,GAAyB,EAAO,UAAW,CAC7C,GAAI,GAAQ,EAAG,MAAO,EAAS,EAAM,SACrC,GAAI,EAAM,QAAQ,MAAQ,OACxB,EAAS,EAAM,QAAQ,aAEvB,QAAS,GAAQ,EAAM,QAAS,GAAS,EAAM,MAAQ,KAAO,EAAM,MAAO,EAAQ,EAAM,KACvF,EAAS,EAAM,SACnB,EAAM,QAAU,GAAI,IAAU,EAAQ,EAAG,OAAO,OAAO,EAAG,EAAO,KAAM,EAAM,QAAS,CAAI,CAC5F,EAAG,QAAQ,EACX,SAAO,IAAM,GACN,CACT,CACA,EAAO,EAAS,SAAS,EACzB,YAAkB,CAChB,GAAI,GAAQ,EAAG,MACX,EAAM,QAAQ,MACZ,GAAM,QAAQ,MAAQ,KACxB,GAAM,SAAW,EAAM,QAAQ,UACjC,EAAM,QAAU,EAAM,QAAQ,KAElC,CACA,EAAO,EAAQ,QAAQ,EACvB,EAAO,IAAM,GACb,WAAgB,EAAQ,CACtB,WAAa,EAAO,CAClB,MAAI,IAAS,EACJ,EAAK,EACL,GAAU,KAAO,GAAS,KAAO,GAAS,KAAO,GAAS,IAC1D,EAAK,EAEL,EAAK,CAAG,CACnB,CACA,SAAO,EAAK,KAAK,EACV,CACT,CACA,EAAO,EAAQ,QAAQ,EACvB,WAAmB,EAAO,EAAO,CAC/B,MAAI,IAAS,MACJ,EAAK,EAAQ,SAAU,CAAK,EAAG,GAAQ,EAAO,GAAG,EAAG,CAAM,EAC/D,GAAS,YACJ,EAAK,EAAQ,MAAM,EAAG,GAAW,EAAW,CAAM,EACvD,GAAS,YACJ,EAAK,EAAQ,MAAM,EAAG,EAAW,CAAM,EAC5C,GAAS,YACJ,EAAG,OAAO,MAAM,QAAS,EAAK,EAAI,EAAK,EAAI,EAAK,EAAQ,MAAM,EAAG,EAAiB,EAAO,GAAG,EAAG,CAAM,EAC1G,GAAS,WACJ,EAAK,EAAO,GAAG,CAAC,EACrB,GAAS,IACJ,EAAK,EAAQ,GAAG,EAAG,GAAkB,GAAO,EAAQ,CAAU,EACnE,GAAS,IACJ,EAAK,EACV,GAAS,KACP,GAAG,MAAM,QAAQ,MAAQ,QAAU,EAAG,MAAM,GAAG,EAAG,MAAM,GAAG,OAAS,IAAM,GAC5E,EAAG,MAAM,GAAG,IAAI,EAAE,EACb,EAAK,EAAQ,MAAM,EAAG,GAAW,EAAW,EAAQ,EAAS,GAElE,GAAS,WACJ,EAAK,CAAW,EACrB,GAAS,MACJ,EAAK,EAAQ,MAAM,EAAG,GAAkB,GAAS,EAAW,EAAY,CAAM,EACnF,GAAS,SAAW,GAAQ,GAAS,YACvC,GAAG,OAAS,UACL,EAAK,EAAQ,OAAQ,GAAS,QAAU,EAAQ,CAAK,EAAG,GAAW,CAAM,GAE9E,GAAS,WACP,GAAQ,GAAS,UACnB,GAAG,OAAS,UACL,EAAK,CAAS,GACZ,GAAS,IAAS,UAAY,GAAS,QAAU,GAAS,SAAW,EAAG,OAAO,MAAM,SAAU,EAAK,EAC7G,GAAG,OAAS,UACR,GAAS,OACJ,EAAK,EAAO,EACZ,GAAS,OACT,EAAK,GAAU,EAAO,UAAU,EAAG,EAAU,EAAO,GAAG,CAAC,EAExD,EAAK,EAAQ,MAAM,EAAG,EAAS,EAAO,GAAG,EAAG,EAAQ,GAAG,EAAG,GAAO,EAAQ,CAAM,GAC/E,GAAQ,GAAS,YAC1B,GAAG,OAAS,UACL,EAAK,EAAQ,MAAM,EAAG,EAAY,EAAW,CAAM,GACjD,GAAQ,GAAS,WAC1B,GAAG,OAAS,UACL,EAAK,CAAS,GAEd,EAAK,EAAQ,MAAM,EAAG,EAAU,EAGvC,GAAS,SACJ,EAAK,EAAQ,MAAM,EAAG,GAAW,EAAO,GAAG,EAAG,EAAQ,IAAK,QAAQ,EAAG,GAAkB,GAAO,EAAQ,EAAQ,CAAU,EAC9H,GAAS,OACJ,EAAK,EAAY,EAAO,GAAG,CAAC,EACjC,GAAS,UACJ,EAAK,EAAO,GAAG,CAAC,EACrB,GAAS,QACJ,EAAK,EAAQ,MAAM,EAAG,EAAa,GAAmB,EAAW,EAAQ,CAAU,EACxF,GAAS,SACJ,EAAK,EAAQ,MAAM,EAAG,GAAa,CAAM,EAC9C,GAAS,SACJ,EAAK,EAAQ,MAAM,EAAG,GAAa,CAAM,EAC9C,GAAS,QACJ,EAAK,CAAS,EACnB,GAAS,IACJ,EAAK,EAAY,CAAS,EAC5B,EAAK,EAAQ,MAAM,EAAG,EAAY,EAAO,GAAG,EAAG,CAAM,CAC9D,CACA,EAAO,EAAW,WAAW,EAC7B,YAA2B,EAAO,CAChC,GAAI,GAAS,IACX,MAAO,GAAK,EAAQ,EAAO,GAAG,CAAC,CACnC,CACA,EAAO,GAAmB,mBAAmB,EAC7C,WAAoB,EAAO,EAAO,CAChC,MAAO,IAAgB,EAAO,EAAO,EAAK,CAC5C,CACA,EAAO,EAAY,YAAY,EAC/B,WAA2B,EAAO,EAAO,CACvC,MAAO,IAAgB,EAAO,EAAO,EAAI,CAC3C,CACA,EAAO,EAAmB,mBAAmB,EAC7C,YAAmB,EAAO,CACxB,MAAI,IAAS,IACJ,EAAK,EACP,EAAK,EAAQ,GAAG,EAAG,EAAiB,EAAO,GAAG,EAAG,CAAM,CAChE,CACA,EAAO,GAAW,WAAW,EAC7B,YAAyB,EAAO,EAAO,EAAS,CAC9C,GAAI,EAAG,MAAM,YAAc,EAAG,OAAO,MAAO,CAC1C,GAAI,GAAO,EAAU,GAAmB,GACxC,GAAI,GAAS,IACX,MAAO,GAAK,EAAa,EAAQ,GAAG,EAAG,EAAS,EAAQ,GAAG,EAAG,EAAQ,EAAO,IAAI,EAAG,EAAM,CAAU,EACjG,GAAI,GAAS,WAChB,MAAO,GAAK,EAAa,EAAS,EAAO,IAAI,EAAG,EAAM,CAAU,CACpE,CACA,GAAI,GAAU,EAAU,EAAuB,EAC/C,MAAI,IAAY,eAAe,CAAK,EAC3B,EAAK,CAAO,EACjB,GAAS,WACJ,EAAK,EAAa,CAAO,EAC9B,GAAS,SAAW,GAAQ,GAAS,YACvC,GAAG,OAAS,UACL,EAAK,EAAQ,MAAM,EAAG,GAAiB,CAAM,GAElD,GAAS,aAAe,GAAS,QAC5B,EAAK,EAAU,EAAoB,CAAU,EAClD,GAAS,IACJ,EAAK,EAAQ,GAAG,EAAG,EAAiB,EAAO,GAAG,EAAG,EAAQ,CAAO,EACrE,GAAS,YAAc,GAAS,SAC3B,EAAK,EAAU,EAAoB,CAAU,EAClD,GAAS,IACJ,EAAK,EAAQ,GAAG,EAAG,GAAc,EAAQ,CAAO,EACrD,GAAS,IACJ,EAAa,GAAS,IAAK,KAAM,CAAO,EAC7C,GAAS,QACJ,EAAK,GAAO,CAAO,EACxB,GAAS,MACJ,EAAK,GAAY,CAAO,CAAC,EAC3B,EAAK,CACd,CACA,EAAO,GAAiB,iBAAiB,EACzC,WAAyB,EAAO,CAC9B,MAAI,GAAM,MAAM,YAAY,EACnB,EAAK,EACP,EAAK,CAAU,CACxB,CACA,EAAO,EAAiB,iBAAiB,EACzC,WAA4B,EAAO,EAAO,CACxC,MAAI,IAAS,IACJ,EAAK,CAAe,EACtB,EAAqB,EAAO,EAAO,EAAK,CACjD,CACA,EAAO,EAAoB,oBAAoB,EAC/C,WAA8B,EAAO,EAAO,EAAS,CACnD,GAAI,GAAK,GAAW,GAAQ,EAAqB,EAC7C,EAAO,GAAW,GAAQ,EAAa,EAC3C,GAAI,GAAS,KACX,MAAO,GAAK,EAAa,EAAU,GAAmB,GAAW,CAAU,EAC7E,GAAI,GAAS,WACX,MAAI,UAAU,KAAK,CAAK,GAAK,GAAQ,GAAS,IACrC,EAAK,CAAE,EACZ,GAAQ,GAAS,KAAO,EAAG,OAAO,MAAM,2BAA4B,EAAK,EACpE,EAAK,EAAQ,GAAG,EAAG,EAAS,EAAU,GAAG,EAAG,EAAQ,CAAE,EAC3D,GAAS,IACJ,EAAK,EAAY,EAAO,GAAG,EAAG,CAAI,EACpC,EAAK,CAAI,EAElB,GAAI,GAAS,QACX,MAAO,GAAK,GAAO,CAAE,EAEvB,GAAI,GAAS,IAEb,IAAI,GAAS,IACX,MAAO,GAAa,EAAmB,IAAK,OAAQ,CAAE,EACxD,GAAI,GAAS,IACX,MAAO,GAAK,GAAU,CAAE,EAC1B,GAAI,GAAS,IACX,MAAO,GAAK,EAAQ,GAAG,EAAG,EAAiB,EAAO,GAAG,EAAG,EAAQ,CAAE,EACpE,GAAI,GAAQ,GAAS,KACnB,SAAG,OAAS,UACL,EAAK,EAAU,CAAE,EAE1B,GAAI,GAAS,SACX,SAAG,MAAM,SAAW,EAAG,OAAS,WAChC,EAAG,OAAO,OAAO,EAAG,OAAO,IAAM,EAAG,OAAO,MAAQ,CAAC,EAC7C,EAAK,CAAI,EAEpB,CACA,EAAO,EAAsB,sBAAsB,EACnD,YAAe,EAAO,EAAO,CAC3B,MAAI,IAAS,QACJ,EAAK,EACV,EAAM,MAAM,EAAM,OAAS,CAAC,GAAK,KAC5B,EAAK,EAAK,EACZ,EAAK,EAAiB,EAAa,CAC5C,CACA,EAAO,GAAO,OAAO,EACrB,YAAuB,EAAO,CAC5B,GAAI,GAAS,IACX,SAAG,OAAS,WACZ,EAAG,MAAM,SAAW,EACb,EAAK,EAAK,CAErB,CACA,EAAO,GAAe,eAAe,EACrC,YAAmB,EAAO,CACxB,UAAa,EAAG,OAAQ,EAAG,KAAK,EACzB,EAAK,GAAS,IAAM,EAAY,CAAU,CACnD,CACA,EAAO,GAAW,WAAW,EAC7B,YAA0B,EAAO,CAC/B,UAAa,EAAG,OAAQ,EAAG,KAAK,EACzB,EAAK,GAAS,IAAM,EAAY,CAAiB,CAC1D,CACA,EAAO,GAAkB,kBAAkB,EAC3C,YAAqB,EAAS,CAC5B,MAAO,UAAS,EAAO,CACrB,MAAI,IAAS,IACJ,EAAK,EAAU,GAAgB,EAAM,EACrC,GAAS,YAAc,EACvB,EAAK,GAAe,EAAU,EAAuB,CAAkB,EAEvE,EAAK,EAAU,EAAoB,CAAU,CACxD,CACF,CACA,EAAO,GAAa,aAAa,EACjC,YAAgB,EAAG,EAAO,CACxB,GAAI,GAAS,SACX,SAAG,OAAS,UACL,EAAK,CAAkB,CAElC,CACA,EAAO,GAAQ,QAAQ,EACvB,YAAuB,EAAG,EAAO,CAC/B,GAAI,GAAS,SACX,SAAG,OAAS,UACL,EAAK,CAAoB,CAEpC,CACA,EAAO,GAAe,eAAe,EACrC,YAAoB,EAAO,CACzB,MAAI,IAAS,IACJ,EAAK,EAAQ,CAAS,EACxB,EAAK,EAAoB,EAAO,GAAG,EAAG,CAAM,CACrD,CACA,EAAO,GAAY,YAAY,EAC/B,YAAkB,EAAO,CACvB,GAAI,GAAS,WACX,SAAG,OAAS,WACL,EAAK,CAEhB,CACA,EAAO,GAAU,UAAU,EAC3B,YAAiB,EAAO,EAAO,CAC7B,GAAI,GAAS,QACX,SAAG,OAAS,WACL,EAAK,EAAO,EACd,GAAI,GAAS,YAAc,EAAG,OAAS,UAAW,CAEvD,GADA,EAAG,OAAS,WACR,GAAS,OAAS,GAAS,MAC7B,MAAO,GAAK,EAAY,EAC1B,GAAI,GACJ,MAAI,IAAQ,EAAG,MAAM,YAAc,EAAG,OAAO,OAAU,GAAI,EAAG,OAAO,MAAM,WAAY,EAAK,IAC1F,GAAG,MAAM,WAAa,EAAG,OAAO,IAAM,EAAE,GAAG,QACtC,EAAK,CAAS,CACvB,KAAO,IAAI,GAAS,UAAY,GAAS,SACvC,SAAG,OAAS,GAAa,WAAa,EAAG,MAAQ,YAC1C,EAAK,CAAS,EAChB,GAAI,GAAS,iBAClB,MAAO,GAAK,CAAS,EAChB,GAAI,GAAQ,GAAW,CAAK,EACjC,SAAG,OAAS,UACL,EAAK,EAAO,EACd,GAAI,GAAS,IAClB,MAAO,GAAK,EAAY,EAAW,EAAO,GAAG,EAAG,CAAS,EACpD,GAAI,GAAS,SAClB,MAAO,GAAK,EAAmB,CAAS,EACnC,GAAI,GAAS,IAClB,SAAG,OAAS,UACL,EAAK,EAAO,EACd,GAAI,GAAS,IAClB,MAAO,GAAK,CAAS,EAEzB,CACA,EAAO,GAAS,SAAS,EACzB,YAAsB,EAAO,CAC3B,MAAI,IAAS,WACJ,EAAK,CAAS,EACvB,GAAG,OAAS,WACL,EAAK,CAAW,EACzB,CACA,EAAO,GAAc,cAAc,EACnC,WAAmB,EAAO,CACxB,GAAI,GAAS,IACX,MAAO,GAAK,CAAiB,EAC/B,GAAI,GAAS,IACX,MAAO,GAAK,CAAW,CAC3B,CACA,EAAO,EAAW,WAAW,EAC7B,WAAkB,EAAM,EAAK,EAAK,CAChC,WAAiB,EAAO,EAAO,CAC7B,GAAI,EAAM,EAAI,QAAQ,CAAK,EAAI,GAAK,GAAS,IAAK,CAChD,GAAI,GAAM,EAAG,MAAM,QACnB,MAAI,GAAI,MAAQ,QACd,GAAI,IAAO,GAAI,KAAO,GAAK,GACtB,EAAK,SAAS,EAAO,EAAQ,CAClC,MAAI,IAAS,GAAO,GAAU,EACrB,EAAK,EACP,EAAK,CAAI,CAClB,EAAG,CAAO,CACZ,CACA,MAAI,IAAS,GAAO,GAAS,EACpB,EAAK,EACV,GAAO,EAAI,QAAQ,GAAG,EAAI,GACrB,EAAK,CAAI,EACX,EAAK,EAAO,CAAG,CAAC,CACzB,CACA,SAAO,EAAS,SAAS,EAClB,SAAS,EAAO,EAAO,CAC5B,MAAI,IAAS,GAAO,GAAS,EACpB,EAAK,EACP,EAAK,EAAM,CAAO,CAC3B,CACF,CACA,EAAO,EAAU,UAAU,EAC3B,WAAsB,EAAM,EAAK,EAAM,CACrC,OAAS,GAAI,EAAG,EAAI,UAAU,OAAQ,IACpC,EAAG,GAAG,KAAK,UAAU,EAAE,EACzB,MAAO,GAAK,EAAQ,EAAK,CAAI,EAAG,EAAS,EAAM,CAAG,EAAG,CAAM,CAC7D,CACA,EAAO,EAAc,cAAc,EACnC,YAAe,EAAO,CACpB,MAAI,IAAS,IACJ,EAAK,EACP,EAAK,EAAW,EAAK,CAC9B,CACA,EAAO,GAAO,OAAO,EACrB,WAAmB,EAAO,EAAO,CAC/B,GAAI,EAAM,CACR,GAAI,GAAS,IACX,MAAO,GAAK,CAAQ,EACtB,GAAI,GAAS,IACX,MAAO,GAAK,CAAS,CACzB,CACF,CACA,EAAO,EAAW,WAAW,EAC7B,YAAuB,EAAO,EAAO,CACnC,GAAI,GAAS,IAAS,KAAO,GAAS,MACpC,MAAO,GAAK,CAAQ,CACxB,CACA,EAAO,GAAe,eAAe,EACrC,YAAsB,EAAO,CAC3B,GAAI,GAAQ,GAAS,IACnB,MAAI,GAAG,OAAO,MAAM,iBAAkB,EAAK,EAClC,EAAK,EAAY,GAAM,CAAQ,EAE/B,EAAK,CAAQ,CAE1B,CACA,EAAO,GAAc,cAAc,EACnC,YAAc,EAAG,EAAO,CACtB,GAAI,GAAS,KACX,SAAG,OAAS,UACL,EAAK,CAEhB,CACA,EAAO,GAAM,MAAM,EACnB,WAAkB,EAAO,EAAO,CAC9B,GAAI,GAAS,SAAW,GAAS,UAAY,GAAS,SAAW,GAAS,WACxE,SAAG,OAAS,UACL,EAAK,GAAS,SAAW,EAAoB,CAAQ,EAE9D,GAAI,GAAS,YAAc,GAAS,OAClC,SAAG,OAAS,OACL,EAAK,CAAS,EAEvB,GAAI,GAAS,KAAO,GAAS,IAC3B,MAAO,GAAK,CAAQ,EACtB,GAAI,GAAS,UAAY,GAAS,UAAY,GAAS,OACrD,MAAO,GAAK,CAAS,EACvB,GAAI,GAAS,IACX,MAAO,GAAK,EAAQ,GAAG,EAAG,EAAS,EAAU,IAAK,GAAG,EAAG,EAAQ,CAAS,EAC3E,GAAI,GAAS,IACX,MAAO,GAAK,EAAQ,GAAG,EAAG,GAAW,EAAQ,CAAS,EACxD,GAAI,GAAS,IACX,MAAO,GAAK,EAAS,GAAS,GAAG,EAAG,GAAiB,CAAS,EAChE,GAAI,GAAS,IACX,MAAO,GAAK,EAAS,EAAU,GAAG,EAAG,CAAQ,EAC/C,GAAI,GAAS,QACX,MAAO,GAAK,GAAW,CAAS,CAEpC,CACA,EAAO,EAAU,UAAU,EAC3B,YAAyB,EAAO,CAC9B,GAAI,GAAS,KACX,MAAO,GAAK,CAAQ,CACxB,CACA,EAAO,GAAiB,iBAAiB,EACzC,YAAmB,EAAO,CACxB,MAAI,GAAM,MAAM,UAAU,EACjB,EAAK,EACV,GAAS,KAAO,GAAS,IACpB,EAAK,EAAS,EAChB,EAAK,EAAU,EAAS,CACjC,CACA,EAAO,GAAW,WAAW,EAC7B,WAAkB,EAAO,EAAO,CAC9B,GAAI,GAAS,YAAc,EAAG,OAAS,UACrC,SAAG,OAAS,WACL,EAAK,CAAQ,EACf,GAAI,GAAS,KAAO,GAAS,UAAY,GAAS,SACvD,MAAO,GAAK,CAAQ,EACf,GAAI,GAAS,IAClB,MAAO,GAAK,CAAQ,EACf,GAAI,GAAS,IAClB,MAAO,GAAK,EAAO,UAAU,EAAG,GAAe,EAAO,GAAG,EAAG,CAAQ,EAC/D,GAAI,GAAS,IAClB,MAAO,GAAK,EAAc,CAAQ,EAC7B,GAAI,CAAC,EAAM,MAAM,YAAY,EAClC,MAAO,GAAK,CAEhB,CACA,EAAO,EAAU,UAAU,EAC3B,YAAmB,EAAO,EAAO,CAC/B,MAAI,IAAS,QACJ,EAAK,EACV,EAAM,MAAM,EAAM,OAAS,CAAC,GAAK,KAC5B,EAAK,EAAS,EAChB,EAAK,EAAU,EAAiB,CACzC,CACA,EAAO,GAAW,WAAW,EAC7B,YAA2B,EAAO,CAChC,GAAI,GAAS,IACX,SAAG,OAAS,WACZ,EAAG,MAAM,SAAW,EACb,EAAK,EAAS,CAEzB,CACA,EAAO,GAAmB,mBAAmB,EAC7C,YAAiB,EAAO,EAAO,CAC7B,MAAI,IAAS,YAAc,EAAG,OAAO,MAAM,WAAY,EAAK,GAAK,GAAS,IACjE,EAAK,EAAO,EACjB,GAAS,IACJ,EAAK,CAAQ,EAClB,GAAS,SACJ,EAAK,EAAO,EACd,EAAK,CAAQ,CACtB,CACA,EAAO,GAAS,SAAS,EACzB,WAAmB,EAAO,EAAO,CAC/B,GAAI,GAAS,IACX,MAAO,GAAK,EAAQ,GAAG,EAAG,EAAS,EAAU,GAAG,EAAG,EAAQ,CAAS,EACtE,GAAI,GAAS,KAAO,GAAS,KAAO,GAAS,IAC3C,MAAO,GAAK,CAAQ,EACtB,GAAI,GAAS,IACX,MAAO,GAAK,EAAU,EAAO,GAAG,EAAG,CAAS,EAC9C,GAAI,GAAS,WAAa,GAAS,aACjC,SAAG,OAAS,UACL,EAAK,CAAQ,EAEtB,GAAI,GAAS,IACX,MAAO,GAAK,EAAU,EAAO,GAAG,EAAG,CAAQ,CAC/C,CACA,EAAO,EAAW,WAAW,EAC7B,YAAuB,EAAG,EAAO,CAC/B,GAAI,GAAS,IACX,MAAO,GAAK,EAAQ,GAAG,EAAG,EAAS,EAAU,GAAG,EAAG,EAAQ,CAAS,CACxE,CACA,EAAO,GAAe,eAAe,EACrC,aAAqB,CACnB,MAAO,GAAK,EAAU,EAAgB,CACxC,CACA,EAAO,GAAW,WAAW,EAC7B,YAA0B,EAAG,EAAO,CAClC,GAAI,GAAS,IACX,MAAO,GAAK,CAAQ,CACxB,CACA,EAAO,GAAkB,kBAAkB,EAC3C,YAAgB,EAAG,EAAO,CACxB,MAAI,IAAS,OACX,GAAG,OAAS,UACL,EAAK,EAAO,GAEd,EAAK,EAAS,EAAW,EAAa,EAAU,CACzD,CACA,EAAO,GAAQ,QAAQ,EACvB,WAAiB,EAAO,EAAO,CAC7B,GAAI,GAAQ,GAAW,CAAK,EAC1B,SAAG,OAAS,UACL,EAAK,CAAO,EAErB,GAAI,GAAS,WACX,SAAS,CAAK,EACP,EAAK,EAEd,GAAI,GAAS,SACX,MAAO,GAAK,CAAO,EACrB,GAAI,GAAS,IACX,MAAO,GAAa,GAAY,GAAG,EACrC,GAAI,GAAS,IACX,MAAO,GAAa,GAAa,GAAG,CACxC,CACA,EAAO,EAAS,SAAS,EACzB,YAAqB,EAAO,EAAO,CACjC,MAAI,IAAS,YAAc,CAAC,EAAG,OAAO,MAAM,QAAS,EAAK,EACxD,GAAS,CAAK,EACP,EAAK,CAAW,GAErB,IAAS,YACX,GAAG,OAAS,YACV,GAAS,SACJ,EAAK,CAAO,EACjB,GAAS,IACJ,EAAK,EACV,GAAS,IACJ,EAAK,EAAY,EAAO,GAAG,EAAG,EAAO,GAAG,EAAG,EAAW,EACxD,EAAK,EAAO,GAAG,EAAG,EAAS,CAAW,EAC/C,CACA,EAAO,GAAa,aAAa,EACjC,aAAsB,CACpB,MAAO,GAAK,EAAS,CAAW,CAClC,CACA,EAAO,GAAY,YAAY,EAC/B,WAAqB,EAAO,EAAO,CACjC,GAAI,GAAS,IACX,MAAO,GAAK,CAAiB,CACjC,CACA,EAAO,EAAa,aAAa,EACjC,YAAoB,EAAO,CACzB,GAAI,GAAS,IACX,MAAO,GAAK,EAAM,CACtB,CACA,EAAO,GAAY,YAAY,EAC/B,YAAmB,EAAO,EAAO,CAC/B,GAAI,GAAS,aAAe,GAAS,OACnC,MAAO,GAAK,EAAQ,OAAQ,MAAM,EAAG,EAAW,CAAM,CAC1D,CACA,EAAO,GAAW,WAAW,EAC7B,YAAiB,EAAO,EAAO,CAC7B,GAAI,GAAS,QACX,MAAO,GAAK,EAAO,EACrB,GAAI,GAAS,IACX,MAAO,GAAK,EAAQ,GAAG,EAAG,GAAU,CAAM,CAC9C,CACA,EAAO,GAAS,SAAS,EACzB,YAAkB,EAAO,CACvB,MAAI,IAAS,MACJ,EAAK,GAAQ,CAAQ,EAC1B,GAAS,WACJ,EAAK,CAAQ,EACf,EAAK,CAAQ,CACtB,CACA,EAAO,GAAU,UAAU,EAC3B,WAAkB,EAAO,EAAO,CAC9B,MAAI,IAAS,IACJ,EAAK,EACV,GAAS,IACJ,EAAK,CAAQ,EAClB,GAAS,MAAQ,GAAS,KAC5B,GAAG,OAAS,UACL,EAAK,EAAY,CAAQ,GAE3B,EAAK,EAAY,CAAQ,CAClC,CACA,EAAO,EAAU,UAAU,EAC3B,WAAqB,EAAO,EAAO,CACjC,GAAI,GAAS,IACX,SAAG,OAAS,UACL,EAAK,CAAW,EAEzB,GAAI,GAAS,WACX,SAAS,CAAK,EACP,EAAK,CAAW,EAEzB,GAAI,GAAS,IACX,MAAO,GAAK,EAAa,EAAQ,GAAG,EAAG,EAAS,EAAQ,GAAG,EAAG,EAAQ,GAAc,EAAW,CAAU,EAC3G,GAAI,GAAQ,GAAS,IACnB,MAAO,GAAK,EAAQ,GAAG,EAAG,EAAS,GAAW,GAAG,EAAG,EAAQ,CAAW,CAC3E,CACA,EAAO,EAAa,aAAa,EACjC,WAAsB,EAAO,EAAO,CAClC,GAAI,GAAS,IACX,SAAG,OAAS,UACL,EAAK,CAAY,EAE1B,GAAI,GAAS,WACX,SAAS,CAAK,EACP,EAAK,CAAY,EAE1B,GAAI,GAAS,IACX,MAAO,GAAK,EAAa,EAAQ,GAAG,EAAG,EAAS,EAAQ,GAAG,EAAG,EAAQ,GAAc,CAAU,EAChG,GAAI,GAAQ,GAAS,IACnB,MAAO,GAAK,EAAQ,GAAG,EAAG,EAAS,GAAW,GAAG,EAAG,EAAQ,CAAY,CAC5E,CACA,EAAO,EAAc,cAAc,EACnC,YAAkB,EAAO,EAAO,CAC9B,GAAI,GAAS,WAAa,GAAS,WACjC,SAAG,OAAS,OACL,EAAK,EAAQ,EACf,GAAI,GAAS,IAClB,MAAO,GAAK,EAAQ,GAAG,EAAG,EAAS,GAAW,GAAG,EAAG,CAAM,CAE9D,CACA,EAAO,GAAU,UAAU,EAC3B,WAAgB,EAAO,EAAO,CAG5B,MAFI,IAAS,KACX,EAAK,EAAY,CAAM,EACrB,GAAS,SACJ,EAAK,CAAM,EAChB,GAAQ,GAAW,CAAK,EAC1B,GAAG,OAAS,UACL,EAAK,CAAM,GAEhB,GAAQ,GAAS,OACZ,EAAK,EAAW,CAAW,EAC7B,EAAK,EAAS,EAAW,CAAW,CAC7C,CACA,EAAO,EAAQ,QAAQ,EACvB,YAAyB,EAAO,EAAO,CACrC,MAAI,IAAS,WACJ,GAAU,EAAO,CAAK,EACxB,GAAe,EAAO,CAAK,CACpC,CACA,EAAO,GAAiB,iBAAiB,EACzC,YAAmB,EAAO,EAAO,CAC/B,GAAI,GAAS,WACX,SAAS,CAAK,EACP,EAAK,EAAc,CAE9B,CACA,EAAO,GAAW,WAAW,EAC7B,YAAwB,EAAO,EAAO,CACpC,GAAI,GAAS,IACX,MAAO,GAAK,EAAQ,GAAG,EAAG,EAAS,GAAW,GAAG,EAAG,EAAQ,EAAc,EAC5E,GAAI,GAAS,WAAa,GAAS,cAAgB,GAAQ,GAAS,IAClE,MAAI,IAAS,cACX,GAAG,OAAS,WACP,EAAK,EAAO,EAAW,EAAY,EAAc,EAE1D,GAAI,GAAS,IACX,MAAO,GAAK,EAAQ,GAAG,EAAG,EAAW,CAAM,CAC/C,CACA,EAAO,GAAgB,gBAAgB,EACvC,WAAmB,EAAO,EAAO,CAC/B,GAAI,GAAS,SAAW,GAAS,YAAe,IAAS,UAAY,GAAS,OAAS,GAAS,OAAS,GAAQ,GAAW,CAAK,IAAM,EAAG,OAAO,MAAM,uBAAwB,EAAK,EAClL,SAAG,OAAS,UACL,EAAK,CAAS,EAEvB,GAAI,GAAS,YAAc,EAAG,OAAS,UACrC,SAAG,OAAS,WACL,EAAK,EAAY,CAAS,EAEnC,GAAI,GAAS,UAAY,GAAS,SAChC,MAAO,GAAK,EAAY,CAAS,EACnC,GAAI,GAAS,IACX,MAAO,GAAK,EAAY,EAAW,EAAO,GAAG,EAAG,EAAY,CAAS,EACvE,GAAI,GAAS,IACX,SAAG,OAAS,UACL,EAAK,CAAS,EAEvB,GAAI,GAAQ,GAAS,IACnB,MAAO,GAAK,EAAc,CAAS,EACrC,GAAI,GAAS,KAAO,GAAS,IAC3B,MAAO,GAAK,CAAS,EACvB,GAAI,GAAS,IACX,MAAO,GAAK,EACd,GAAI,GAAS,IACX,MAAO,GAAK,EAAY,CAAS,CACrC,CACA,EAAO,EAAW,WAAW,EAC7B,WAAoB,EAAO,EAAO,CAGhC,GAFI,GAAS,KAET,GAAS,IACX,MAAO,GAAK,CAAU,EACxB,GAAI,GAAS,IACX,MAAO,GAAK,EAAU,CAAW,EACnC,GAAI,GAAS,IACX,MAAO,GAAK,CAAiB,EAC/B,GAAI,GAAU,EAAG,MAAM,QAAQ,KAAM,EAAc,GAAW,EAAQ,MAAQ,YAC9E,MAAO,GAAK,EAAc,EAAe,CAAW,CACtD,CACA,EAAO,EAAY,YAAY,EAC/B,YAAqB,EAAO,EAAO,CACjC,MAAI,IAAS,IACX,GAAG,OAAS,UACL,EAAK,GAAW,EAAO,GAAG,CAAC,GAEhC,GAAS,UACX,GAAG,OAAS,UACL,EAAK,EAAY,EAAO,GAAG,CAAC,GAEjC,GAAS,IACJ,EAAK,EAAS,GAAa,GAAG,EAAG,GAAW,EAAO,GAAG,CAAC,EACzD,EAAK,CAAS,CACvB,CACA,EAAO,GAAa,aAAa,EACjC,YAAqB,EAAO,EAAO,CACjC,GAAI,GAAS,KACX,SAAG,OAAS,UACL,EAAK,EAAO,UAAU,CAAC,EAEhC,GAAI,GAAS,WACX,MAAO,GAAK,EAAmB,EAAW,CAC9C,CACA,EAAO,GAAa,aAAa,EACjC,YAAqB,EAAO,CAC1B,MAAI,IAAS,SACJ,EAAK,EACV,GAAS,IACJ,EAAK,CAAU,EACpB,GAAS,IACJ,EAAK,CAAkB,EACzB,EAAK,GAAY,GAAkB,EAAS,CACrD,CACA,EAAO,GAAa,aAAa,EACjC,YAAoB,EAAO,EAAO,CAChC,MAAI,IAAS,IACJ,EAAa,GAAY,GAAG,EACjC,IAAS,YACX,EAAS,CAAK,EACZ,GAAS,KACX,GAAG,OAAS,WACP,EAAK,EAAO,EACrB,CACA,EAAO,GAAY,YAAY,EAC/B,YAA0B,EAAO,CAC/B,GAAI,GAAS,IACX,MAAO,GAAK,GAAY,EAAgB,CAC5C,CACA,EAAO,GAAkB,kBAAkB,EAC3C,YAAiB,EAAO,EAAO,CAC7B,GAAI,GAAS,KACX,SAAG,OAAS,UACL,EAAK,EAAU,CAE1B,CACA,EAAO,GAAS,SAAS,EACzB,YAAmB,EAAO,EAAO,CAC/B,GAAI,GAAS,OACX,SAAG,OAAS,UACL,EAAK,CAAU,CAE1B,CACA,EAAO,GAAW,WAAW,EAC7B,YAAsB,EAAO,CAC3B,MAAI,IAAS,IACJ,EAAK,EACP,EAAK,EAAS,EAAmB,GAAG,CAAC,CAC9C,CACA,EAAO,GAAc,cAAc,EACnC,aAAmB,CACjB,MAAO,GAAK,EAAQ,MAAM,EAAG,EAAS,EAAO,GAAG,EAAG,EAAQ,GAAG,EAAG,EAAS,GAAY,GAAG,EAAG,EAAQ,CAAM,CAC5G,CACA,EAAO,GAAS,SAAS,EACzB,aAAsB,CACpB,MAAO,GAAK,EAAS,CAAW,CAClC,CACA,EAAO,GAAY,YAAY,EAC/B,YAA8B,EAAO,EAAW,CAC9C,MAAO,GAAM,UAAY,YAAc,EAAM,UAAY,KAAO,GAAe,KAAK,EAAU,OAAO,CAAC,CAAC,GAAK,OAAO,KAAK,EAAU,OAAO,CAAC,CAAC,CAC7I,CACA,EAAO,GAAsB,sBAAsB,EACnD,YAA2B,EAAQ,EAAO,EAAQ,CAChD,MAAO,GAAM,UAAY,GAAa,iFAAiF,KAAK,EAAM,QAAQ,GAAK,EAAM,UAAY,SAAW,SAAS,KAAK,EAAO,OAAO,MAAM,EAAG,EAAO,IAAO,IAAU,EAAE,CAAC,CAC9O,CACA,SAAO,GAAmB,mBAAmB,EACtC,CACL,WAAY,SAAS,EAAY,CAC/B,GAAI,GAAQ,CACV,SAAU,EACV,SAAU,MACV,GAAI,CAAC,EACL,QAAS,GAAI,IAAW,IAAc,GAAK,EAAY,EAAG,QAAS,EAAK,EACxE,UAAW,EAAa,UACxB,QAAS,EAAa,WAAa,GAAI,GAAQ,KAAM,KAAM,EAAK,EAChE,SAAU,GAAc,CAC1B,EACA,MAAI,GAAa,YAAc,MAAO,GAAa,YAAc,UAC/D,GAAM,WAAa,EAAa,YAC3B,CACT,EACA,MAAO,SAAS,EAAQ,EAAO,CAO7B,GANI,EAAO,IAAI,GACR,GAAM,QAAQ,eAAe,OAAO,GACvC,GAAM,QAAQ,MAAQ,IACxB,EAAM,SAAW,EAAO,YAAY,EACpC,GAAa,EAAQ,CAAK,GAExB,EAAM,UAAY,GAAgB,EAAO,SAAS,EACpD,MAAO,MACT,GAAI,GAAQ,EAAM,SAAS,EAAQ,CAAK,EACxC,MAAI,IAAQ,UACH,EACT,GAAM,SAAW,GAAQ,YAAe,KAAW,MAAQ,IAAW,MAAQ,SAAW,EAClF,GAAQ,EAAO,EAAO,EAAM,GAAS,CAAM,EACpD,EACA,OAAQ,SAAS,EAAO,EAAW,CACjC,GAAI,EAAM,UAAY,GAAgB,EAAM,UAAY,EACtD,MAAO,GAAW,KACpB,GAAI,EAAM,UAAY,EACpB,MAAO,GACT,GAAI,GAAY,GAAa,EAAU,OAAO,CAAC,EAAG,EAAU,EAAM,QAAS,EAC3E,GAAI,CAAC,aAAa,KAAK,CAAS,EAC9B,OAAS,GAAI,EAAM,GAAG,OAAS,EAAG,GAAK,EAAG,EAAE,EAAG,CAC7C,GAAI,GAAI,EAAM,GAAG,GACjB,GAAI,GAAK,EACP,EAAU,EAAQ,aACX,GAAK,IAAa,GAAK,EAC9B,KACJ,CACF,KAAQ,GAAQ,MAAQ,QAAU,EAAQ,MAAQ,SAAY,IAAa,KAAQ,GAAM,EAAM,GAAG,EAAM,GAAG,OAAS,KAAQ,IAAO,GAAsB,GAAO,IAAyB,CAAC,mBAAmB,KAAK,CAAS,IACzN,EAAU,EAAQ,KAChB,IAAmB,EAAQ,MAAQ,KAAO,EAAQ,KAAK,MAAQ,QACjE,GAAU,EAAQ,MACpB,GAAI,GAAQ,EAAQ,KAAM,EAAU,GAAa,EACjD,MAAI,IAAS,SACJ,EAAQ,SAAY,GAAM,UAAY,YAAc,EAAM,UAAY,IAAM,EAAQ,KAAK,OAAS,EAAI,GACtG,GAAS,QAAU,GAAa,IAChC,EAAQ,SACR,GAAS,OACT,EAAQ,SAAW,EACnB,GAAS,OACT,EAAQ,SAAY,IAAqB,EAAO,CAAS,EAAI,IAAmB,EAAa,GAC7F,EAAQ,MAAQ,UAAY,CAAC,GAAW,EAAa,oBAAsB,GAC3E,EAAQ,SAAY,uBAAsB,KAAK,CAAS,EAAI,EAAa,EAAI,GAC7E,EAAQ,MACR,EAAQ,OAAU,GAAU,EAAI,GAEhC,EAAQ,SAAY,GAAU,EAAI,EAC7C,EACA,cAAe,oCACf,kBAAmB,EAAW,KAAO,KACrC,gBAAiB,EAAW,KAAO,KACnC,qBAAsB,EAAW,KAAO,MACxC,YAAa,EAAW,KAAO,KAC/B,KAAM,QACN,cAAe,iBACf,WAAY,EAAW,OAAS,aAChC,cACA,WACA,qBACA,eAAgB,SAAS,EAAO,CAC9B,GAAQ,EAAO,OAAQ,OAAQ,OAAQ,GAAI,GAAW,aAAa,GAAI,EAAG,IAAI,CAAC,CACjF,CACF,CACF,CAAC,EACD,EAAW,eAAe,YAAa,aAAc,OAAO,EAC5D,EAAW,WAAW,kBAAmB,YAAY,EACrD,EAAW,WAAW,kBAAmB,YAAY,EACrD,EAAW,WAAW,yBAA0B,YAAY,EAC5D,EAAW,WAAW,2BAA4B,YAAY,EAC9D,EAAW,WAAW,yBAA0B,YAAY,EAC5D,EAAW,WAAW,mBAAoB,CAAE,KAAM,aAAc,KAAM,EAAK,CAAC,EAC5E,EAAW,WAAW,qBAAsB,CAAE,KAAM,aAAc,KAAM,EAAK,CAAC,EAC9E,EAAW,WAAW,4BAA6B,CAAE,KAAM,aAAc,KAAM,EAAK,CAAC,EACrF,EAAW,WAAW,sBAAuB,CAAE,KAAM,aAAc,OAAQ,EAAK,CAAC,EACjF,EAAW,WAAW,kBAAmB,CAAE,KAAM,aAAc,WAAY,EAAK,CAAC,EACjF,EAAW,WAAW,yBAA0B,CAAE,KAAM,aAAc,WAAY,EAAK,CAAC,CAC1F,CAAC,CACH,GAAG,EACH,GAAI,IAAa,GAAa,QAC1B,GAA+B,OAAO,OAAuB,GAAiB,CAChF,UAAW,KACX,CAAC,OAAO,aAAc,SACtB,QAAW,EACb,EAAG,CAAC,GAAa,OAAO,CAAC,CAAC,C","file":"static/9620.f57c7a9d.chunk.js","sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { a as codemirror } from \"./codemirror.es.js\";\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, \"_mergeNamespaces\");\nvar javascript$2 = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(codemirror.exports);\n  })(function(CodeMirror) {\n    CodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n      var indentUnit = config.indentUnit;\n      var statementIndent = parserConfig.statementIndent;\n      var jsonldMode = parserConfig.jsonld;\n      var jsonMode = parserConfig.json || jsonldMode;\n      var trackScope = parserConfig.trackScope !== false;\n      var isTS = parserConfig.typescript;\n      var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n      var keywords = function() {\n        function kw(type2) {\n          return { type: type2, style: \"keyword\" };\n        }\n        __name(kw, \"kw\");\n        var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n        var operator = kw(\"operator\"), atom = { type: \"atom\", style: \"atom\" };\n        return {\n          \"if\": kw(\"if\"),\n          \"while\": A,\n          \"with\": A,\n          \"else\": B,\n          \"do\": B,\n          \"try\": B,\n          \"finally\": B,\n          \"return\": D,\n          \"break\": D,\n          \"continue\": D,\n          \"new\": kw(\"new\"),\n          \"delete\": C,\n          \"void\": C,\n          \"throw\": C,\n          \"debugger\": kw(\"debugger\"),\n          \"var\": kw(\"var\"),\n          \"const\": kw(\"var\"),\n          \"let\": kw(\"var\"),\n          \"function\": kw(\"function\"),\n          \"catch\": kw(\"catch\"),\n          \"for\": kw(\"for\"),\n          \"switch\": kw(\"switch\"),\n          \"case\": kw(\"case\"),\n          \"default\": kw(\"default\"),\n          \"in\": operator,\n          \"typeof\": operator,\n          \"instanceof\": operator,\n          \"true\": atom,\n          \"false\": atom,\n          \"null\": atom,\n          \"undefined\": atom,\n          \"NaN\": atom,\n          \"Infinity\": atom,\n          \"this\": kw(\"this\"),\n          \"class\": kw(\"class\"),\n          \"super\": kw(\"atom\"),\n          \"yield\": C,\n          \"export\": kw(\"export\"),\n          \"import\": kw(\"import\"),\n          \"extends\": C,\n          \"await\": C\n        };\n      }();\n      var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n      function readRegexp(stream) {\n        var escaped = false, next, inSet = false;\n        while ((next = stream.next()) != null) {\n          if (!escaped) {\n            if (next == \"/\" && !inSet)\n              return;\n            if (next == \"[\")\n              inSet = true;\n            else if (inSet && next == \"]\")\n              inSet = false;\n          }\n          escaped = !escaped && next == \"\\\\\";\n        }\n      }\n      __name(readRegexp, \"readRegexp\");\n      var type, content;\n      function ret(tp, style, cont2) {\n        type = tp;\n        content = cont2;\n        return style;\n      }\n      __name(ret, \"ret\");\n      function tokenBase(stream, state) {\n        var ch = stream.next();\n        if (ch == '\"' || ch == \"'\") {\n          state.tokenize = tokenString(ch);\n          return state.tokenize(stream, state);\n        } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n          return ret(\"number\", \"number\");\n        } else if (ch == \".\" && stream.match(\"..\")) {\n          return ret(\"spread\", \"meta\");\n        } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n          return ret(ch);\n        } else if (ch == \"=\" && stream.eat(\">\")) {\n          return ret(\"=>\", \"operator\");\n        } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n          return ret(\"number\", \"number\");\n        } else if (/\\d/.test(ch)) {\n          stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n          return ret(\"number\", \"number\");\n        } else if (ch == \"/\") {\n          if (stream.eat(\"*\")) {\n            state.tokenize = tokenComment;\n            return tokenComment(stream, state);\n          } else if (stream.eat(\"/\")) {\n            stream.skipToEnd();\n            return ret(\"comment\", \"comment\");\n          } else if (expressionAllowed(stream, state, 1)) {\n            readRegexp(stream);\n            stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n            return ret(\"regexp\", \"string-2\");\n          } else {\n            stream.eat(\"=\");\n            return ret(\"operator\", \"operator\", stream.current());\n          }\n        } else if (ch == \"`\") {\n          state.tokenize = tokenQuasi;\n          return tokenQuasi(stream, state);\n        } else if (ch == \"#\" && stream.peek() == \"!\") {\n          stream.skipToEnd();\n          return ret(\"meta\", \"meta\");\n        } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n          return ret(\"variable\", \"property\");\n        } else if (ch == \"<\" && stream.match(\"!--\") || ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start))) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else if (isOperatorChar.test(ch)) {\n          if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n            if (stream.eat(\"=\")) {\n              if (ch == \"!\" || ch == \"=\")\n                stream.eat(\"=\");\n            } else if (/[<>*+\\-|&?]/.test(ch)) {\n              stream.eat(ch);\n              if (ch == \">\")\n                stream.eat(ch);\n            }\n          }\n          if (ch == \"?\" && stream.eat(\".\"))\n            return ret(\".\");\n          return ret(\"operator\", \"operator\", stream.current());\n        } else if (wordRE.test(ch)) {\n          stream.eatWhile(wordRE);\n          var word = stream.current();\n          if (state.lastType != \".\") {\n            if (keywords.propertyIsEnumerable(word)) {\n              var kw = keywords[word];\n              return ret(kw.type, kw.style, word);\n            }\n            if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n              return ret(\"async\", \"keyword\", word);\n          }\n          return ret(\"variable\", \"variable\", word);\n        }\n      }\n      __name(tokenBase, \"tokenBase\");\n      function tokenString(quote) {\n        return function(stream, state) {\n          var escaped = false, next;\n          if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)) {\n            state.tokenize = tokenBase;\n            return ret(\"jsonld-keyword\", \"meta\");\n          }\n          while ((next = stream.next()) != null) {\n            if (next == quote && !escaped)\n              break;\n            escaped = !escaped && next == \"\\\\\";\n          }\n          if (!escaped)\n            state.tokenize = tokenBase;\n          return ret(\"string\", \"string\");\n        };\n      }\n      __name(tokenString, \"tokenString\");\n      function tokenComment(stream, state) {\n        var maybeEnd = false, ch;\n        while (ch = stream.next()) {\n          if (ch == \"/\" && maybeEnd) {\n            state.tokenize = tokenBase;\n            break;\n          }\n          maybeEnd = ch == \"*\";\n        }\n        return ret(\"comment\", \"comment\");\n      }\n      __name(tokenComment, \"tokenComment\");\n      function tokenQuasi(stream, state) {\n        var escaped = false, next;\n        while ((next = stream.next()) != null) {\n          if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n            state.tokenize = tokenBase;\n            break;\n          }\n          escaped = !escaped && next == \"\\\\\";\n        }\n        return ret(\"quasi\", \"string-2\", stream.current());\n      }\n      __name(tokenQuasi, \"tokenQuasi\");\n      var brackets = \"([{}])\";\n      function findFatArrow(stream, state) {\n        if (state.fatArrowAt)\n          state.fatArrowAt = null;\n        var arrow = stream.string.indexOf(\"=>\", stream.start);\n        if (arrow < 0)\n          return;\n        if (isTS) {\n          var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow));\n          if (m)\n            arrow = m.index;\n        }\n        var depth = 0, sawSomething = false;\n        for (var pos = arrow - 1; pos >= 0; --pos) {\n          var ch = stream.string.charAt(pos);\n          var bracket = brackets.indexOf(ch);\n          if (bracket >= 0 && bracket < 3) {\n            if (!depth) {\n              ++pos;\n              break;\n            }\n            if (--depth == 0) {\n              if (ch == \"(\")\n                sawSomething = true;\n              break;\n            }\n          } else if (bracket >= 3 && bracket < 6) {\n            ++depth;\n          } else if (wordRE.test(ch)) {\n            sawSomething = true;\n          } else if (/[\"'\\/`]/.test(ch)) {\n            for (; ; --pos) {\n              if (pos == 0)\n                return;\n              var next = stream.string.charAt(pos - 1);\n              if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") {\n                pos--;\n                break;\n              }\n            }\n          } else if (sawSomething && !depth) {\n            ++pos;\n            break;\n          }\n        }\n        if (sawSomething && !depth)\n          state.fatArrowAt = pos;\n      }\n      __name(findFatArrow, \"findFatArrow\");\n      var atomicTypes = {\n        \"atom\": true,\n        \"number\": true,\n        \"variable\": true,\n        \"string\": true,\n        \"regexp\": true,\n        \"this\": true,\n        \"import\": true,\n        \"jsonld-keyword\": true\n      };\n      function JSLexical(indented, column, type2, align, prev, info) {\n        this.indented = indented;\n        this.column = column;\n        this.type = type2;\n        this.prev = prev;\n        this.info = info;\n        if (align != null)\n          this.align = align;\n      }\n      __name(JSLexical, \"JSLexical\");\n      function inScope(state, varname) {\n        if (!trackScope)\n          return false;\n        for (var v = state.localVars; v; v = v.next)\n          if (v.name == varname)\n            return true;\n        for (var cx2 = state.context; cx2; cx2 = cx2.prev) {\n          for (var v = cx2.vars; v; v = v.next)\n            if (v.name == varname)\n              return true;\n        }\n      }\n      __name(inScope, \"inScope\");\n      function parseJS(state, style, type2, content2, stream) {\n        var cc = state.cc;\n        cx.state = state;\n        cx.stream = stream;\n        cx.marked = null, cx.cc = cc;\n        cx.style = style;\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = true;\n        while (true) {\n          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n          if (combinator(type2, content2)) {\n            while (cc.length && cc[cc.length - 1].lex)\n              cc.pop()();\n            if (cx.marked)\n              return cx.marked;\n            if (type2 == \"variable\" && inScope(state, content2))\n              return \"variable-2\";\n            return style;\n          }\n        }\n      }\n      __name(parseJS, \"parseJS\");\n      var cx = { state: null, column: null, marked: null, cc: null };\n      function pass() {\n        for (var i = arguments.length - 1; i >= 0; i--)\n          cx.cc.push(arguments[i]);\n      }\n      __name(pass, \"pass\");\n      function cont() {\n        pass.apply(null, arguments);\n        return true;\n      }\n      __name(cont, \"cont\");\n      function inList(name, list) {\n        for (var v = list; v; v = v.next)\n          if (v.name == name)\n            return true;\n        return false;\n      }\n      __name(inList, \"inList\");\n      function register(varname) {\n        var state = cx.state;\n        cx.marked = \"def\";\n        if (!trackScope)\n          return;\n        if (state.context) {\n          if (state.lexical.info == \"var\" && state.context && state.context.block) {\n            var newContext = registerVarScoped(varname, state.context);\n            if (newContext != null) {\n              state.context = newContext;\n              return;\n            }\n          } else if (!inList(varname, state.localVars)) {\n            state.localVars = new Var(varname, state.localVars);\n            return;\n          }\n        }\n        if (parserConfig.globalVars && !inList(varname, state.globalVars))\n          state.globalVars = new Var(varname, state.globalVars);\n      }\n      __name(register, \"register\");\n      function registerVarScoped(varname, context) {\n        if (!context) {\n          return null;\n        } else if (context.block) {\n          var inner = registerVarScoped(varname, context.prev);\n          if (!inner)\n            return null;\n          if (inner == context.prev)\n            return context;\n          return new Context(inner, context.vars, true);\n        } else if (inList(varname, context.vars)) {\n          return context;\n        } else {\n          return new Context(context.prev, new Var(varname, context.vars), false);\n        }\n      }\n      __name(registerVarScoped, \"registerVarScoped\");\n      function isModifier(name) {\n        return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\";\n      }\n      __name(isModifier, \"isModifier\");\n      function Context(prev, vars, block2) {\n        this.prev = prev;\n        this.vars = vars;\n        this.block = block2;\n      }\n      __name(Context, \"Context\");\n      function Var(name, next) {\n        this.name = name;\n        this.next = next;\n      }\n      __name(Var, \"Var\");\n      var defaultVars = new Var(\"this\", new Var(\"arguments\", null));\n      function pushcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);\n        cx.state.localVars = defaultVars;\n      }\n      __name(pushcontext, \"pushcontext\");\n      function pushblockcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);\n        cx.state.localVars = null;\n      }\n      __name(pushblockcontext, \"pushblockcontext\");\n      pushcontext.lex = pushblockcontext.lex = true;\n      function popcontext() {\n        cx.state.localVars = cx.state.context.vars;\n        cx.state.context = cx.state.context.prev;\n      }\n      __name(popcontext, \"popcontext\");\n      popcontext.lex = true;\n      function pushlex(type2, info) {\n        var result = /* @__PURE__ */ __name(function() {\n          var state = cx.state, indent = state.indented;\n          if (state.lexical.type == \"stat\")\n            indent = state.lexical.indented;\n          else\n            for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n              indent = outer.indented;\n          state.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state.lexical, info);\n        }, \"result\");\n        result.lex = true;\n        return result;\n      }\n      __name(pushlex, \"pushlex\");\n      function poplex() {\n        var state = cx.state;\n        if (state.lexical.prev) {\n          if (state.lexical.type == \")\")\n            state.indented = state.lexical.indented;\n          state.lexical = state.lexical.prev;\n        }\n      }\n      __name(poplex, \"poplex\");\n      poplex.lex = true;\n      function expect(wanted) {\n        function exp(type2) {\n          if (type2 == wanted)\n            return cont();\n          else if (wanted == \";\" || type2 == \"}\" || type2 == \")\" || type2 == \"]\")\n            return pass();\n          else\n            return cont(exp);\n        }\n        __name(exp, \"exp\");\n        return exp;\n      }\n      __name(expect, \"expect\");\n      function statement(type2, value) {\n        if (type2 == \"var\")\n          return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n        if (type2 == \"keyword a\")\n          return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n        if (type2 == \"keyword b\")\n          return cont(pushlex(\"form\"), statement, poplex);\n        if (type2 == \"keyword d\")\n          return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n        if (type2 == \"debugger\")\n          return cont(expect(\";\"));\n        if (type2 == \"{\")\n          return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n        if (type2 == \";\")\n          return cont();\n        if (type2 == \"if\") {\n          if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n            cx.state.cc.pop()();\n          return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n        }\n        if (type2 == \"function\")\n          return cont(functiondef);\n        if (type2 == \"for\")\n          return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n        if (type2 == \"class\" || isTS && value == \"interface\") {\n          cx.marked = \"keyword\";\n          return cont(pushlex(\"form\", type2 == \"class\" ? type2 : value), className, poplex);\n        }\n        if (type2 == \"variable\") {\n          if (isTS && value == \"declare\") {\n            cx.marked = \"keyword\";\n            return cont(statement);\n          } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n            cx.marked = \"keyword\";\n            if (value == \"enum\")\n              return cont(enumdef);\n            else if (value == \"type\")\n              return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n            else\n              return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex);\n          } else if (isTS && value == \"namespace\") {\n            cx.marked = \"keyword\";\n            return cont(pushlex(\"form\"), expression, statement, poplex);\n          } else if (isTS && value == \"abstract\") {\n            cx.marked = \"keyword\";\n            return cont(statement);\n          } else {\n            return cont(pushlex(\"stat\"), maybelabel);\n          }\n        }\n        if (type2 == \"switch\")\n          return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext, block, poplex, poplex, popcontext);\n        if (type2 == \"case\")\n          return cont(expression, expect(\":\"));\n        if (type2 == \"default\")\n          return cont(expect(\":\"));\n        if (type2 == \"catch\")\n          return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n        if (type2 == \"export\")\n          return cont(pushlex(\"stat\"), afterExport, poplex);\n        if (type2 == \"import\")\n          return cont(pushlex(\"stat\"), afterImport, poplex);\n        if (type2 == \"async\")\n          return cont(statement);\n        if (value == \"@\")\n          return cont(expression, statement);\n        return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n      }\n      __name(statement, \"statement\");\n      function maybeCatchBinding(type2) {\n        if (type2 == \"(\")\n          return cont(funarg, expect(\")\"));\n      }\n      __name(maybeCatchBinding, \"maybeCatchBinding\");\n      function expression(type2, value) {\n        return expressionInner(type2, value, false);\n      }\n      __name(expression, \"expression\");\n      function expressionNoComma(type2, value) {\n        return expressionInner(type2, value, true);\n      }\n      __name(expressionNoComma, \"expressionNoComma\");\n      function parenExpr(type2) {\n        if (type2 != \"(\")\n          return pass();\n        return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex);\n      }\n      __name(parenExpr, \"parenExpr\");\n      function expressionInner(type2, value, noComma) {\n        if (cx.state.fatArrowAt == cx.stream.start) {\n          var body = noComma ? arrowBodyNoComma : arrowBody;\n          if (type2 == \"(\")\n            return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n          else if (type2 == \"variable\")\n            return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n        }\n        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n        if (atomicTypes.hasOwnProperty(type2))\n          return cont(maybeop);\n        if (type2 == \"function\")\n          return cont(functiondef, maybeop);\n        if (type2 == \"class\" || isTS && value == \"interface\") {\n          cx.marked = \"keyword\";\n          return cont(pushlex(\"form\"), classExpression, poplex);\n        }\n        if (type2 == \"keyword c\" || type2 == \"async\")\n          return cont(noComma ? expressionNoComma : expression);\n        if (type2 == \"(\")\n          return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n        if (type2 == \"operator\" || type2 == \"spread\")\n          return cont(noComma ? expressionNoComma : expression);\n        if (type2 == \"[\")\n          return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n        if (type2 == \"{\")\n          return contCommasep(objprop, \"}\", null, maybeop);\n        if (type2 == \"quasi\")\n          return pass(quasi, maybeop);\n        if (type2 == \"new\")\n          return cont(maybeTarget(noComma));\n        return cont();\n      }\n      __name(expressionInner, \"expressionInner\");\n      function maybeexpression(type2) {\n        if (type2.match(/[;\\}\\)\\],]/))\n          return pass();\n        return pass(expression);\n      }\n      __name(maybeexpression, \"maybeexpression\");\n      function maybeoperatorComma(type2, value) {\n        if (type2 == \",\")\n          return cont(maybeexpression);\n        return maybeoperatorNoComma(type2, value, false);\n      }\n      __name(maybeoperatorComma, \"maybeoperatorComma\");\n      function maybeoperatorNoComma(type2, value, noComma) {\n        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n        var expr = noComma == false ? expression : expressionNoComma;\n        if (type2 == \"=>\")\n          return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n        if (type2 == \"operator\") {\n          if (/\\+\\+|--/.test(value) || isTS && value == \"!\")\n            return cont(me);\n          if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n            return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n          if (value == \"?\")\n            return cont(expression, expect(\":\"), expr);\n          return cont(expr);\n        }\n        if (type2 == \"quasi\") {\n          return pass(quasi, me);\n        }\n        if (type2 == \";\")\n          return;\n        if (type2 == \"(\")\n          return contCommasep(expressionNoComma, \")\", \"call\", me);\n        if (type2 == \".\")\n          return cont(property, me);\n        if (type2 == \"[\")\n          return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n        if (isTS && value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(typeexpr, me);\n        }\n        if (type2 == \"regexp\") {\n          cx.state.lastType = cx.marked = \"operator\";\n          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);\n          return cont(expr);\n        }\n      }\n      __name(maybeoperatorNoComma, \"maybeoperatorNoComma\");\n      function quasi(type2, value) {\n        if (type2 != \"quasi\")\n          return pass();\n        if (value.slice(value.length - 2) != \"${\")\n          return cont(quasi);\n        return cont(maybeexpression, continueQuasi);\n      }\n      __name(quasi, \"quasi\");\n      function continueQuasi(type2) {\n        if (type2 == \"}\") {\n          cx.marked = \"string-2\";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasi);\n        }\n      }\n      __name(continueQuasi, \"continueQuasi\");\n      function arrowBody(type2) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type2 == \"{\" ? statement : expression);\n      }\n      __name(arrowBody, \"arrowBody\");\n      function arrowBodyNoComma(type2) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type2 == \"{\" ? statement : expressionNoComma);\n      }\n      __name(arrowBodyNoComma, \"arrowBodyNoComma\");\n      function maybeTarget(noComma) {\n        return function(type2) {\n          if (type2 == \".\")\n            return cont(noComma ? targetNoComma : target);\n          else if (type2 == \"variable\" && isTS)\n            return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);\n          else\n            return pass(noComma ? expressionNoComma : expression);\n        };\n      }\n      __name(maybeTarget, \"maybeTarget\");\n      function target(_, value) {\n        if (value == \"target\") {\n          cx.marked = \"keyword\";\n          return cont(maybeoperatorComma);\n        }\n      }\n      __name(target, \"target\");\n      function targetNoComma(_, value) {\n        if (value == \"target\") {\n          cx.marked = \"keyword\";\n          return cont(maybeoperatorNoComma);\n        }\n      }\n      __name(targetNoComma, \"targetNoComma\");\n      function maybelabel(type2) {\n        if (type2 == \":\")\n          return cont(poplex, statement);\n        return pass(maybeoperatorComma, expect(\";\"), poplex);\n      }\n      __name(maybelabel, \"maybelabel\");\n      function property(type2) {\n        if (type2 == \"variable\") {\n          cx.marked = \"property\";\n          return cont();\n        }\n      }\n      __name(property, \"property\");\n      function objprop(type2, value) {\n        if (type2 == \"async\") {\n          cx.marked = \"property\";\n          return cont(objprop);\n        } else if (type2 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          if (value == \"get\" || value == \"set\")\n            return cont(getterSetter);\n          var m;\n          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n            cx.state.fatArrowAt = cx.stream.pos + m[0].length;\n          return cont(afterprop);\n        } else if (type2 == \"number\" || type2 == \"string\") {\n          cx.marked = jsonldMode ? \"property\" : cx.style + \" property\";\n          return cont(afterprop);\n        } else if (type2 == \"jsonld-keyword\") {\n          return cont(afterprop);\n        } else if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(objprop);\n        } else if (type2 == \"[\") {\n          return cont(expression, maybetype, expect(\"]\"), afterprop);\n        } else if (type2 == \"spread\") {\n          return cont(expressionNoComma, afterprop);\n        } else if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(objprop);\n        } else if (type2 == \":\") {\n          return pass(afterprop);\n        }\n      }\n      __name(objprop, \"objprop\");\n      function getterSetter(type2) {\n        if (type2 != \"variable\")\n          return pass(afterprop);\n        cx.marked = \"property\";\n        return cont(functiondef);\n      }\n      __name(getterSetter, \"getterSetter\");\n      function afterprop(type2) {\n        if (type2 == \":\")\n          return cont(expressionNoComma);\n        if (type2 == \"(\")\n          return pass(functiondef);\n      }\n      __name(afterprop, \"afterprop\");\n      function commasep(what, end, sep) {\n        function proceed(type2, value) {\n          if (sep ? sep.indexOf(type2) > -1 : type2 == \",\") {\n            var lex = cx.state.lexical;\n            if (lex.info == \"call\")\n              lex.pos = (lex.pos || 0) + 1;\n            return cont(function(type3, value2) {\n              if (type3 == end || value2 == end)\n                return pass();\n              return pass(what);\n            }, proceed);\n          }\n          if (type2 == end || value == end)\n            return cont();\n          if (sep && sep.indexOf(\";\") > -1)\n            return pass(what);\n          return cont(expect(end));\n        }\n        __name(proceed, \"proceed\");\n        return function(type2, value) {\n          if (type2 == end || value == end)\n            return cont();\n          return pass(what, proceed);\n        };\n      }\n      __name(commasep, \"commasep\");\n      function contCommasep(what, end, info) {\n        for (var i = 3; i < arguments.length; i++)\n          cx.cc.push(arguments[i]);\n        return cont(pushlex(end, info), commasep(what, end), poplex);\n      }\n      __name(contCommasep, \"contCommasep\");\n      function block(type2) {\n        if (type2 == \"}\")\n          return cont();\n        return pass(statement, block);\n      }\n      __name(block, \"block\");\n      function maybetype(type2, value) {\n        if (isTS) {\n          if (type2 == \":\")\n            return cont(typeexpr);\n          if (value == \"?\")\n            return cont(maybetype);\n        }\n      }\n      __name(maybetype, \"maybetype\");\n      function maybetypeOrIn(type2, value) {\n        if (isTS && (type2 == \":\" || value == \"in\"))\n          return cont(typeexpr);\n      }\n      __name(maybetypeOrIn, \"maybetypeOrIn\");\n      function mayberettype(type2) {\n        if (isTS && type2 == \":\") {\n          if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false))\n            return cont(expression, isKW, typeexpr);\n          else\n            return cont(typeexpr);\n        }\n      }\n      __name(mayberettype, \"mayberettype\");\n      function isKW(_, value) {\n        if (value == \"is\") {\n          cx.marked = \"keyword\";\n          return cont();\n        }\n      }\n      __name(isKW, \"isKW\");\n      function typeexpr(type2, value) {\n        if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n          cx.marked = \"keyword\";\n          return cont(value == \"typeof\" ? expressionNoComma : typeexpr);\n        }\n        if (type2 == \"variable\" || value == \"void\") {\n          cx.marked = \"type\";\n          return cont(afterType);\n        }\n        if (value == \"|\" || value == \"&\")\n          return cont(typeexpr);\n        if (type2 == \"string\" || type2 == \"number\" || type2 == \"atom\")\n          return cont(afterType);\n        if (type2 == \"[\")\n          return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType);\n        if (type2 == \"{\")\n          return cont(pushlex(\"}\"), typeprops, poplex, afterType);\n        if (type2 == \"(\")\n          return cont(commasep(typearg, \")\"), maybeReturnType, afterType);\n        if (type2 == \"<\")\n          return cont(commasep(typeexpr, \">\"), typeexpr);\n        if (type2 == \"quasi\") {\n          return pass(quasiType, afterType);\n        }\n      }\n      __name(typeexpr, \"typeexpr\");\n      function maybeReturnType(type2) {\n        if (type2 == \"=>\")\n          return cont(typeexpr);\n      }\n      __name(maybeReturnType, \"maybeReturnType\");\n      function typeprops(type2) {\n        if (type2.match(/[\\}\\)\\]]/))\n          return cont();\n        if (type2 == \",\" || type2 == \";\")\n          return cont(typeprops);\n        return pass(typeprop, typeprops);\n      }\n      __name(typeprops, \"typeprops\");\n      function typeprop(type2, value) {\n        if (type2 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          return cont(typeprop);\n        } else if (value == \"?\" || type2 == \"number\" || type2 == \"string\") {\n          return cont(typeprop);\n        } else if (type2 == \":\") {\n          return cont(typeexpr);\n        } else if (type2 == \"[\") {\n          return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop);\n        } else if (type2 == \"(\") {\n          return pass(functiondecl, typeprop);\n        } else if (!type2.match(/[;\\}\\)\\],]/)) {\n          return cont();\n        }\n      }\n      __name(typeprop, \"typeprop\");\n      function quasiType(type2, value) {\n        if (type2 != \"quasi\")\n          return pass();\n        if (value.slice(value.length - 2) != \"${\")\n          return cont(quasiType);\n        return cont(typeexpr, continueQuasiType);\n      }\n      __name(quasiType, \"quasiType\");\n      function continueQuasiType(type2) {\n        if (type2 == \"}\") {\n          cx.marked = \"string-2\";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasiType);\n        }\n      }\n      __name(continueQuasiType, \"continueQuasiType\");\n      function typearg(type2, value) {\n        if (type2 == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\")\n          return cont(typearg);\n        if (type2 == \":\")\n          return cont(typeexpr);\n        if (type2 == \"spread\")\n          return cont(typearg);\n        return pass(typeexpr);\n      }\n      __name(typearg, \"typearg\");\n      function afterType(type2, value) {\n        if (value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n        if (value == \"|\" || type2 == \".\" || value == \"&\")\n          return cont(typeexpr);\n        if (type2 == \"[\")\n          return cont(typeexpr, expect(\"]\"), afterType);\n        if (value == \"extends\" || value == \"implements\") {\n          cx.marked = \"keyword\";\n          return cont(typeexpr);\n        }\n        if (value == \"?\")\n          return cont(typeexpr, expect(\":\"), typeexpr);\n      }\n      __name(afterType, \"afterType\");\n      function maybeTypeArgs(_, value) {\n        if (value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n      }\n      __name(maybeTypeArgs, \"maybeTypeArgs\");\n      function typeparam() {\n        return pass(typeexpr, maybeTypeDefault);\n      }\n      __name(typeparam, \"typeparam\");\n      function maybeTypeDefault(_, value) {\n        if (value == \"=\")\n          return cont(typeexpr);\n      }\n      __name(maybeTypeDefault, \"maybeTypeDefault\");\n      function vardef(_, value) {\n        if (value == \"enum\") {\n          cx.marked = \"keyword\";\n          return cont(enumdef);\n        }\n        return pass(pattern, maybetype, maybeAssign, vardefCont);\n      }\n      __name(vardef, \"vardef\");\n      function pattern(type2, value) {\n        if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(pattern);\n        }\n        if (type2 == \"variable\") {\n          register(value);\n          return cont();\n        }\n        if (type2 == \"spread\")\n          return cont(pattern);\n        if (type2 == \"[\")\n          return contCommasep(eltpattern, \"]\");\n        if (type2 == \"{\")\n          return contCommasep(proppattern, \"}\");\n      }\n      __name(pattern, \"pattern\");\n      function proppattern(type2, value) {\n        if (type2 == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n          register(value);\n          return cont(maybeAssign);\n        }\n        if (type2 == \"variable\")\n          cx.marked = \"property\";\n        if (type2 == \"spread\")\n          return cont(pattern);\n        if (type2 == \"}\")\n          return pass();\n        if (type2 == \"[\")\n          return cont(expression, expect(\"]\"), expect(\":\"), proppattern);\n        return cont(expect(\":\"), pattern, maybeAssign);\n      }\n      __name(proppattern, \"proppattern\");\n      function eltpattern() {\n        return pass(pattern, maybeAssign);\n      }\n      __name(eltpattern, \"eltpattern\");\n      function maybeAssign(_type, value) {\n        if (value == \"=\")\n          return cont(expressionNoComma);\n      }\n      __name(maybeAssign, \"maybeAssign\");\n      function vardefCont(type2) {\n        if (type2 == \",\")\n          return cont(vardef);\n      }\n      __name(vardefCont, \"vardefCont\");\n      function maybeelse(type2, value) {\n        if (type2 == \"keyword b\" && value == \"else\")\n          return cont(pushlex(\"form\", \"else\"), statement, poplex);\n      }\n      __name(maybeelse, \"maybeelse\");\n      function forspec(type2, value) {\n        if (value == \"await\")\n          return cont(forspec);\n        if (type2 == \"(\")\n          return cont(pushlex(\")\"), forspec1, poplex);\n      }\n      __name(forspec, \"forspec\");\n      function forspec1(type2) {\n        if (type2 == \"var\")\n          return cont(vardef, forspec2);\n        if (type2 == \"variable\")\n          return cont(forspec2);\n        return pass(forspec2);\n      }\n      __name(forspec1, \"forspec1\");\n      function forspec2(type2, value) {\n        if (type2 == \")\")\n          return cont();\n        if (type2 == \";\")\n          return cont(forspec2);\n        if (value == \"in\" || value == \"of\") {\n          cx.marked = \"keyword\";\n          return cont(expression, forspec2);\n        }\n        return pass(expression, forspec2);\n      }\n      __name(forspec2, \"forspec2\");\n      function functiondef(type2, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(functiondef);\n        }\n        if (type2 == \"variable\") {\n          register(value);\n          return cont(functiondef);\n        }\n        if (type2 == \"(\")\n          return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n        if (isTS && value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef);\n      }\n      __name(functiondef, \"functiondef\");\n      function functiondecl(type2, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(functiondecl);\n        }\n        if (type2 == \"variable\") {\n          register(value);\n          return cont(functiondecl);\n        }\n        if (type2 == \"(\")\n          return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n        if (isTS && value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl);\n      }\n      __name(functiondecl, \"functiondecl\");\n      function typename(type2, value) {\n        if (type2 == \"keyword\" || type2 == \"variable\") {\n          cx.marked = \"type\";\n          return cont(typename);\n        } else if (value == \"<\") {\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex);\n        }\n      }\n      __name(typename, \"typename\");\n      function funarg(type2, value) {\n        if (value == \"@\")\n          cont(expression, funarg);\n        if (type2 == \"spread\")\n          return cont(funarg);\n        if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(funarg);\n        }\n        if (isTS && type2 == \"this\")\n          return cont(maybetype, maybeAssign);\n        return pass(pattern, maybetype, maybeAssign);\n      }\n      __name(funarg, \"funarg\");\n      function classExpression(type2, value) {\n        if (type2 == \"variable\")\n          return className(type2, value);\n        return classNameAfter(type2, value);\n      }\n      __name(classExpression, \"classExpression\");\n      function className(type2, value) {\n        if (type2 == \"variable\") {\n          register(value);\n          return cont(classNameAfter);\n        }\n      }\n      __name(className, \"className\");\n      function classNameAfter(type2, value) {\n        if (value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter);\n        if (value == \"extends\" || value == \"implements\" || isTS && type2 == \",\") {\n          if (value == \"implements\")\n            cx.marked = \"keyword\";\n          return cont(isTS ? typeexpr : expression, classNameAfter);\n        }\n        if (type2 == \"{\")\n          return cont(pushlex(\"}\"), classBody, poplex);\n      }\n      __name(classNameAfter, \"classNameAfter\");\n      function classBody(type2, value) {\n        if (type2 == \"async\" || type2 == \"variable\" && (value == \"static\" || value == \"get\" || value == \"set\" || isTS && isModifier(value)) && cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false)) {\n          cx.marked = \"keyword\";\n          return cont(classBody);\n        }\n        if (type2 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          return cont(classfield, classBody);\n        }\n        if (type2 == \"number\" || type2 == \"string\")\n          return cont(classfield, classBody);\n        if (type2 == \"[\")\n          return cont(expression, maybetype, expect(\"]\"), classfield, classBody);\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(classBody);\n        }\n        if (isTS && type2 == \"(\")\n          return pass(functiondecl, classBody);\n        if (type2 == \";\" || type2 == \",\")\n          return cont(classBody);\n        if (type2 == \"}\")\n          return cont();\n        if (value == \"@\")\n          return cont(expression, classBody);\n      }\n      __name(classBody, \"classBody\");\n      function classfield(type2, value) {\n        if (value == \"!\")\n          return cont(classfield);\n        if (value == \"?\")\n          return cont(classfield);\n        if (type2 == \":\")\n          return cont(typeexpr, maybeAssign);\n        if (value == \"=\")\n          return cont(expressionNoComma);\n        var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\";\n        return pass(isInterface ? functiondecl : functiondef);\n      }\n      __name(classfield, \"classfield\");\n      function afterExport(type2, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(maybeFrom, expect(\";\"));\n        }\n        if (value == \"default\") {\n          cx.marked = \"keyword\";\n          return cont(expression, expect(\";\"));\n        }\n        if (type2 == \"{\")\n          return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n        return pass(statement);\n      }\n      __name(afterExport, \"afterExport\");\n      function exportField(type2, value) {\n        if (value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(expect(\"variable\"));\n        }\n        if (type2 == \"variable\")\n          return pass(expressionNoComma, exportField);\n      }\n      __name(exportField, \"exportField\");\n      function afterImport(type2) {\n        if (type2 == \"string\")\n          return cont();\n        if (type2 == \"(\")\n          return pass(expression);\n        if (type2 == \".\")\n          return pass(maybeoperatorComma);\n        return pass(importSpec, maybeMoreImports, maybeFrom);\n      }\n      __name(afterImport, \"afterImport\");\n      function importSpec(type2, value) {\n        if (type2 == \"{\")\n          return contCommasep(importSpec, \"}\");\n        if (type2 == \"variable\")\n          register(value);\n        if (value == \"*\")\n          cx.marked = \"keyword\";\n        return cont(maybeAs);\n      }\n      __name(importSpec, \"importSpec\");\n      function maybeMoreImports(type2) {\n        if (type2 == \",\")\n          return cont(importSpec, maybeMoreImports);\n      }\n      __name(maybeMoreImports, \"maybeMoreImports\");\n      function maybeAs(_type, value) {\n        if (value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(importSpec);\n        }\n      }\n      __name(maybeAs, \"maybeAs\");\n      function maybeFrom(_type, value) {\n        if (value == \"from\") {\n          cx.marked = \"keyword\";\n          return cont(expression);\n        }\n      }\n      __name(maybeFrom, \"maybeFrom\");\n      function arrayLiteral(type2) {\n        if (type2 == \"]\")\n          return cont();\n        return pass(commasep(expressionNoComma, \"]\"));\n      }\n      __name(arrayLiteral, \"arrayLiteral\");\n      function enumdef() {\n        return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex);\n      }\n      __name(enumdef, \"enumdef\");\n      function enummember() {\n        return pass(pattern, maybeAssign);\n      }\n      __name(enummember, \"enummember\");\n      function isContinuedStatement(state, textAfter) {\n        return state.lastType == \"operator\" || state.lastType == \",\" || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));\n      }\n      __name(isContinuedStatement, \"isContinuedStatement\");\n      function expressionAllowed(stream, state, backUp) {\n        return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) || state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));\n      }\n      __name(expressionAllowed, \"expressionAllowed\");\n      return {\n        startState: function(basecolumn) {\n          var state = {\n            tokenize: tokenBase,\n            lastType: \"sof\",\n            cc: [],\n            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n            localVars: parserConfig.localVars,\n            context: parserConfig.localVars && new Context(null, null, false),\n            indented: basecolumn || 0\n          };\n          if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n            state.globalVars = parserConfig.globalVars;\n          return state;\n        },\n        token: function(stream, state) {\n          if (stream.sol()) {\n            if (!state.lexical.hasOwnProperty(\"align\"))\n              state.lexical.align = false;\n            state.indented = stream.indentation();\n            findFatArrow(stream, state);\n          }\n          if (state.tokenize != tokenComment && stream.eatSpace())\n            return null;\n          var style = state.tokenize(stream, state);\n          if (type == \"comment\")\n            return style;\n          state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n          return parseJS(state, style, type, content, stream);\n        },\n        indent: function(state, textAfter) {\n          if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)\n            return CodeMirror.Pass;\n          if (state.tokenize != tokenBase)\n            return 0;\n          var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;\n          if (!/^\\s*else\\b/.test(textAfter))\n            for (var i = state.cc.length - 1; i >= 0; --i) {\n              var c = state.cc[i];\n              if (c == poplex)\n                lexical = lexical.prev;\n              else if (c != maybeelse && c != popcontext)\n                break;\n            }\n          while ((lexical.type == \"stat\" || lexical.type == \"form\") && (firstChar == \"}\" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter)))\n            lexical = lexical.prev;\n          if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n            lexical = lexical.prev;\n          var type2 = lexical.type, closing = firstChar == type2;\n          if (type2 == \"vardef\")\n            return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n          else if (type2 == \"form\" && firstChar == \"{\")\n            return lexical.indented;\n          else if (type2 == \"form\")\n            return lexical.indented + indentUnit;\n          else if (type2 == \"stat\")\n            return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n          else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n            return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n          else if (lexical.align)\n            return lexical.column + (closing ? 0 : 1);\n          else\n            return lexical.indented + (closing ? 0 : indentUnit);\n        },\n        electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n        blockCommentStart: jsonMode ? null : \"/*\",\n        blockCommentEnd: jsonMode ? null : \"*/\",\n        blockCommentContinue: jsonMode ? null : \" * \",\n        lineComment: jsonMode ? null : \"//\",\n        fold: \"brace\",\n        closeBrackets: \"()[]{}''\\\"\\\"``\",\n        helperType: jsonMode ? \"json\" : \"javascript\",\n        jsonldMode,\n        jsonMode,\n        expressionAllowed,\n        skipExpression: function(state) {\n          parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null));\n        }\n      };\n    });\n    CodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n    CodeMirror.defineMIME(\"text/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\n    CodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\n    CodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n  });\n})();\nvar javascript = javascript$2.exports;\nvar javascript$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": javascript\n}, [javascript$2.exports]));\nexport { javascript$1 as j };\n"],"sourceRoot":""}