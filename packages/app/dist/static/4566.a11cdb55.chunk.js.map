{"version":3,"sources":["webpack://example-app/../node_modules/@graphiql/react/dist/mode.es3.js","webpack://example-app/../node_modules/@graphiql/react/dist/onlineParser.es.js"],"names":[],"mappings":"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","file":"static/4566.a11cdb55.chunk.js","sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"graphql\";\nimport { p, l as list, o as opt, t } from \"./index.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport \"react\";\nimport \"react-dom\";\nCodeMirror.defineMode(\"graphql-variables\", (config) => {\n  const parser = onlineParser({\n    eatWhitespace: (stream) => stream.eatSpace(),\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: { tabSize: config.tabSize }\n  });\n  return {\n    config,\n    startState: parser.startState,\n    token: parser.token,\n    indent,\n    electricInput: /^\\s*[}\\]]/,\n    fold: \"brace\",\n    closeBrackets: {\n      pairs: '[]{}\"\"',\n      explode: \"[]{}\"\n    }\n  };\n});\nfunction indent(state, textAfter) {\n  var _a, _b;\n  const levels = state.levels;\n  const level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a = this.electricInput) === null || _a === void 0 ? void 0 : _a.test(textAfter)) ? 1 : 0);\n  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);\n}\n__name(indent, \"indent\");\nconst LexRules = {\n  Punctuation: /^\\[|]|\\{|\\}|:|,/,\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n  String: /^\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?/,\n  Keyword: /^true|false|null/\n};\nconst ParseRules = {\n  Document: [p(\"{\"), list(\"Variable\", opt(p(\",\"))), p(\"}\")],\n  Variable: [namedKey(\"variable\"), p(\":\"), \"Value\"],\n  Value(token) {\n    switch (token.kind) {\n      case \"Number\":\n        return \"NumberValue\";\n      case \"String\":\n        return \"StringValue\";\n      case \"Punctuation\":\n        switch (token.value) {\n          case \"[\":\n            return \"ListValue\";\n          case \"{\":\n            return \"ObjectValue\";\n        }\n        return null;\n      case \"Keyword\":\n        switch (token.value) {\n          case \"true\":\n          case \"false\":\n            return \"BooleanValue\";\n          case \"null\":\n            return \"NullValue\";\n        }\n        return null;\n    }\n  },\n  NumberValue: [t(\"Number\", \"number\")],\n  StringValue: [t(\"String\", \"string\")],\n  BooleanValue: [t(\"Keyword\", \"builtin\")],\n  NullValue: [t(\"Keyword\", \"keyword\")],\n  ListValue: [p(\"[\"), list(\"Value\", opt(p(\",\"))), p(\"]\")],\n  ObjectValue: [p(\"{\"), list(\"ObjectField\", opt(p(\",\"))), p(\"}\")],\n  ObjectField: [namedKey(\"attribute\"), p(\":\"), \"Value\"]\n};\nfunction namedKey(style) {\n  return {\n    style,\n    match: (token) => token.kind === \"String\",\n    update(state, token) {\n      state.name = token.value.slice(1, -1);\n    }\n  };\n}\n__name(namedKey, \"namedKey\");\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\nfunction onlineParser(options = {\n  eatWhitespace: (stream) => stream.eatWhile(isIgnored),\n  lexRules: LexRules,\n  parseRules: ParseRules,\n  editorConfig: {}\n}) {\n  return {\n    startState() {\n      const initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n__name(onlineParser, \"onlineParser\");\nfunction getToken(stream, state, options) {\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n  if (stream.sol()) {\n    const tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n  const token = lex(lexRules, stream);\n  if (!token) {\n    const matchedSomething = stream.match(/\\S+/);\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n  const backupState = assign({}, state);\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      const levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n  while (state.rule) {\n    let expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n    if (state.needsSeperator) {\n      expected = expected && (expected === null || expected === void 0 ? void 0 : expected.separator);\n    }\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n__name(getToken, \"getToken\");\nfunction assign(to, from) {\n  const keys = Object.keys(from);\n  for (let i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n__name(assign, \"assign\");\nconst SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n}\n__name(pushRule, \"pushRule\");\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n}\n__name(popRule, \"popRule\");\nfunction advanceRule(state, successful) {\n  if (isList(state) && state.rule) {\n    const step = state.rule[state.step];\n    if (step.separator) {\n      const separator = step.separator;\n      state.needsSeperator = !state.needsSeperator;\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    }\n    if (successful) {\n      return;\n    }\n  }\n  state.needsSeperator = false;\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    if (state.rule) {\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n__name(advanceRule, \"advanceRule\");\nfunction isList(state) {\n  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n__name(isList, \"isList\");\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n__name(unsuccessful, \"unsuccessful\");\nfunction lex(lexRules, stream) {\n  const kinds = Object.keys(lexRules);\n  for (let i = 0; i < kinds.length; i++) {\n    const match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n__name(lex, \"lex\");\nexport { onlineParser as o };\n"],"sourceRoot":""}