{"version":3,"sources":["webpack://example-app/../node_modules/react-virtualized-auto-sizer/dist/index.esm.js","webpack://example-app/../node_modules/react-window/dist/index.esm.js"],"names":[],"mappings":"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","file":"static/7423.3de0de42.chunk.js","sourcesContent":["import { createElement, PureComponent } from 'react';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n/**\n * Detect Element Resize.\n * https://github.com/sdecima/javascript-detect-element-resize\n * Sebastian Decima\n *\n * Forked from version 0.5.3; includes the following modifications:\n * 1) Guard against unsafe 'window' and 'document' references (to support SSR).\n * 2) Defer initialization code via a top-level function wrapper (to support SSR).\n * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.\n * 4) Add nonce for style element.\n **/\n\n// Check `document` and `window` in case of server-side rendering\nvar windowObject = void 0;\nif (typeof window !== 'undefined') {\n  windowObject = window;\n\n  // eslint-disable-next-line no-restricted-globals\n} else if (typeof self !== 'undefined') {\n  // eslint-disable-next-line no-restricted-globals\n  windowObject = self;\n} else {\n  windowObject = global;\n}\n\nvar cancelFrame = null;\nvar requestFrame = null;\n\nvar TIMEOUT_DURATION = 20;\n\nvar clearTimeoutFn = windowObject.clearTimeout;\nvar setTimeoutFn = windowObject.setTimeout;\n\nvar cancelAnimationFrameFn = windowObject.cancelAnimationFrame || windowObject.mozCancelAnimationFrame || windowObject.webkitCancelAnimationFrame;\n\nvar requestAnimationFrameFn = windowObject.requestAnimationFrame || windowObject.mozRequestAnimationFrame || windowObject.webkitRequestAnimationFrame;\n\nif (cancelAnimationFrameFn == null || requestAnimationFrameFn == null) {\n  // For environments that don't support animation frame,\n  // fallback to a setTimeout based approach.\n  cancelFrame = clearTimeoutFn;\n  requestFrame = function requestAnimationFrameViaSetTimeout(callback) {\n    return setTimeoutFn(callback, TIMEOUT_DURATION);\n  };\n} else {\n  // Counter intuitively, environments that support animation frames can be trickier.\n  // Chrome's \"Throttle non-visible cross-origin iframes\" flag can prevent rAFs from being called.\n  // In this case, we should fallback to a setTimeout() implementation.\n  cancelFrame = function cancelFrame(_ref) {\n    var _ref2 = slicedToArray(_ref, 2),\n        animationFrameID = _ref2[0],\n        timeoutID = _ref2[1];\n\n    cancelAnimationFrameFn(animationFrameID);\n    clearTimeoutFn(timeoutID);\n  };\n  requestFrame = function requestAnimationFrameWithSetTimeoutFallback(callback) {\n    var animationFrameID = requestAnimationFrameFn(function animationFrameCallback() {\n      clearTimeoutFn(timeoutID);\n      callback();\n    });\n\n    var timeoutID = setTimeoutFn(function timeoutCallback() {\n      cancelAnimationFrameFn(animationFrameID);\n      callback();\n    }, TIMEOUT_DURATION);\n\n    return [animationFrameID, timeoutID];\n  };\n}\n\nfunction createDetectElementResize(nonce) {\n  var animationKeyframes = void 0;\n  var animationName = void 0;\n  var animationStartEvent = void 0;\n  var animationStyle = void 0;\n  var checkTriggers = void 0;\n  var resetTriggers = void 0;\n  var scrollListener = void 0;\n\n  var attachEvent = typeof document !== 'undefined' && document.attachEvent;\n  if (!attachEvent) {\n    resetTriggers = function resetTriggers(element) {\n      var triggers = element.__resizeTriggers__,\n          expand = triggers.firstElementChild,\n          contract = triggers.lastElementChild,\n          expandChild = expand.firstElementChild;\n      contract.scrollLeft = contract.scrollWidth;\n      contract.scrollTop = contract.scrollHeight;\n      expandChild.style.width = expand.offsetWidth + 1 + 'px';\n      expandChild.style.height = expand.offsetHeight + 1 + 'px';\n      expand.scrollLeft = expand.scrollWidth;\n      expand.scrollTop = expand.scrollHeight;\n    };\n\n    checkTriggers = function checkTriggers(element) {\n      return element.offsetWidth !== element.__resizeLast__.width || element.offsetHeight !== element.__resizeLast__.height;\n    };\n\n    scrollListener = function scrollListener(e) {\n      // Don't measure (which forces) reflow for scrolls that happen inside of children!\n      if (e.target.className && typeof e.target.className.indexOf === 'function' && e.target.className.indexOf('contract-trigger') < 0 && e.target.className.indexOf('expand-trigger') < 0) {\n        return;\n      }\n\n      var element = this;\n      resetTriggers(this);\n      if (this.__resizeRAF__) {\n        cancelFrame(this.__resizeRAF__);\n      }\n      this.__resizeRAF__ = requestFrame(function animationFrame() {\n        if (checkTriggers(element)) {\n          element.__resizeLast__.width = element.offsetWidth;\n          element.__resizeLast__.height = element.offsetHeight;\n          element.__resizeListeners__.forEach(function forEachResizeListener(fn) {\n            fn.call(element, e);\n          });\n        }\n      });\n    };\n\n    /* Detect CSS Animations support to detect element display/re-attach */\n    var animation = false;\n    var keyframeprefix = '';\n    animationStartEvent = 'animationstart';\n    var domPrefixes = 'Webkit Moz O ms'.split(' ');\n    var startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' ');\n    var pfx = '';\n    {\n      var elm = document.createElement('fakeelement');\n      if (elm.style.animationName !== undefined) {\n        animation = true;\n      }\n\n      if (animation === false) {\n        for (var i = 0; i < domPrefixes.length; i++) {\n          if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {\n            pfx = domPrefixes[i];\n            keyframeprefix = '-' + pfx.toLowerCase() + '-';\n            animationStartEvent = startEvents[i];\n            animation = true;\n            break;\n          }\n        }\n      }\n    }\n\n    animationName = 'resizeanim';\n    animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';\n    animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';\n  }\n\n  var createStyles = function createStyles(doc) {\n    if (!doc.getElementById('detectElementResize')) {\n      //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360\n      var css = (animationKeyframes ? animationKeyframes : '') + '.resize-triggers { ' + (animationStyle ? animationStyle : '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',\n          head = doc.head || doc.getElementsByTagName('head')[0],\n          style = doc.createElement('style');\n\n      style.id = 'detectElementResize';\n      style.type = 'text/css';\n\n      if (nonce != null) {\n        style.setAttribute('nonce', nonce);\n      }\n\n      if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n      } else {\n        style.appendChild(doc.createTextNode(css));\n      }\n\n      head.appendChild(style);\n    }\n  };\n\n  var addResizeListener = function addResizeListener(element, fn) {\n    if (attachEvent) {\n      element.attachEvent('onresize', fn);\n    } else {\n      if (!element.__resizeTriggers__) {\n        var doc = element.ownerDocument;\n        var elementStyle = windowObject.getComputedStyle(element);\n        if (elementStyle && elementStyle.position === 'static') {\n          element.style.position = 'relative';\n        }\n        createStyles(doc);\n        element.__resizeLast__ = {};\n        element.__resizeListeners__ = [];\n        (element.__resizeTriggers__ = doc.createElement('div')).className = 'resize-triggers';\n        var expandTrigger = doc.createElement('div');\n        expandTrigger.className = 'expand-trigger';\n        expandTrigger.appendChild(doc.createElement('div'));\n        var contractTrigger = doc.createElement('div');\n        contractTrigger.className = 'contract-trigger';\n        element.__resizeTriggers__.appendChild(expandTrigger);\n        element.__resizeTriggers__.appendChild(contractTrigger);\n        element.appendChild(element.__resizeTriggers__);\n        resetTriggers(element);\n        element.addEventListener('scroll', scrollListener, true);\n\n        /* Listen for a css animation to detect element display/re-attach */\n        if (animationStartEvent) {\n          element.__resizeTriggers__.__animationListener__ = function animationListener(e) {\n            if (e.animationName === animationName) {\n              resetTriggers(element);\n            }\n          };\n          element.__resizeTriggers__.addEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);\n        }\n      }\n      element.__resizeListeners__.push(fn);\n    }\n  };\n\n  var removeResizeListener = function removeResizeListener(element, fn) {\n    if (attachEvent) {\n      element.detachEvent('onresize', fn);\n    } else {\n      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);\n      if (!element.__resizeListeners__.length) {\n        element.removeEventListener('scroll', scrollListener, true);\n        if (element.__resizeTriggers__.__animationListener__) {\n          element.__resizeTriggers__.removeEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);\n          element.__resizeTriggers__.__animationListener__ = null;\n        }\n        try {\n          element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);\n        } catch (e) {\n          // Preact compat; see developit/preact-compat/issues/228\n        }\n      }\n    }\n  };\n\n  return {\n    addResizeListener: addResizeListener,\n    removeResizeListener: removeResizeListener\n  };\n}\n\nvar AutoSizer = function (_React$PureComponent) {\n  inherits(AutoSizer, _React$PureComponent);\n\n  function AutoSizer() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, AutoSizer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = AutoSizer.__proto__ || Object.getPrototypeOf(AutoSizer)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      height: _this.props.defaultHeight || 0,\n      width: _this.props.defaultWidth || 0\n    }, _this._onResize = function () {\n      var _this$props = _this.props,\n          disableHeight = _this$props.disableHeight,\n          disableWidth = _this$props.disableWidth,\n          onResize = _this$props.onResize;\n\n\n      if (_this._parentNode) {\n        // Guard against AutoSizer component being removed from the DOM immediately after being added.\n        // This can result in invalid style values which can result in NaN values if we don't handle them.\n        // See issue #150 for more context.\n\n        var _height = _this._parentNode.offsetHeight || 0;\n        var _width = _this._parentNode.offsetWidth || 0;\n\n        var _style = window.getComputedStyle(_this._parentNode) || {};\n        var paddingLeft = parseInt(_style.paddingLeft, 10) || 0;\n        var paddingRight = parseInt(_style.paddingRight, 10) || 0;\n        var paddingTop = parseInt(_style.paddingTop, 10) || 0;\n        var paddingBottom = parseInt(_style.paddingBottom, 10) || 0;\n\n        var newHeight = _height - paddingTop - paddingBottom;\n        var newWidth = _width - paddingLeft - paddingRight;\n\n        if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {\n          _this.setState({\n            height: _height - paddingTop - paddingBottom,\n            width: _width - paddingLeft - paddingRight\n          });\n\n          onResize({ height: _height, width: _width });\n        }\n      }\n    }, _this._setRef = function (autoSizer) {\n      _this._autoSizer = autoSizer;\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(AutoSizer, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var nonce = this.props.nonce;\n\n      if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {\n        // Delay access of parentNode until mount.\n        // This handles edge-cases where the component has already been unmounted before its ref has been set,\n        // As well as libraries like react-lite which have a slightly different lifecycle.\n        this._parentNode = this._autoSizer.parentNode;\n\n        // Defer requiring resize handler in order to support server-side rendering.\n        // See issue #41\n        this._detectElementResize = createDetectElementResize(nonce);\n        this._detectElementResize.addResizeListener(this._parentNode, this._onResize);\n\n        this._onResize();\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._detectElementResize && this._parentNode) {\n        this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          children = _props.children,\n          className = _props.className,\n          disableHeight = _props.disableHeight,\n          disableWidth = _props.disableWidth,\n          style = _props.style;\n      var _state = this.state,\n          height = _state.height,\n          width = _state.width;\n\n      // Outer div should not force width/height since that may prevent containers from shrinking.\n      // Inner component should overflow and use calculated width/height.\n      // See issue #68 for more information.\n\n      var outerStyle = { overflow: 'visible' };\n      var childParams = {};\n\n      // Avoid rendering children before the initial measurements have been collected.\n      // At best this would just be wasting cycles.\n      var bailoutOnChildren = false;\n\n      if (!disableHeight) {\n        if (height === 0) {\n          bailoutOnChildren = true;\n        }\n        outerStyle.height = 0;\n        childParams.height = height;\n      }\n\n      if (!disableWidth) {\n        if (width === 0) {\n          bailoutOnChildren = true;\n        }\n        outerStyle.width = 0;\n        childParams.width = width;\n      }\n\n      return createElement(\n        'div',\n        {\n          className: className,\n          ref: this._setRef,\n          style: _extends({}, outerStyle, style)\n        },\n        !bailoutOnChildren && children(childParams)\n      );\n    }\n  }]);\n  return AutoSizer;\n}(PureComponent);\n\nAutoSizer.defaultProps = {\n  onResize: function onResize() {},\n  disableHeight: false,\n  disableWidth: false,\n  style: {}\n};\n\nexport default AutoSizer;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _class;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar _excluded = [\"style\"],\n    _excluded2 = [\"style\"];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n"],"sourceRoot":""}