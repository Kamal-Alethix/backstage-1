{"version":3,"sources":["webpack://example-app/../node_modules/@graphiql/react/dist/Range.es.js","webpack://example-app/javascript/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","webpack://example-app/../node_modules/@graphiql/react/dist/lint.es.js","webpack://example-app/../node_modules/@graphiql/react/dist/onlineParser.es.js"],"names":[],"mappings":"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","file":"static/998.a054bbfa.chunk.js","sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match && match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whitespaces = match[0];\n        let pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\n__name(CharacterStream, \"CharacterStream\");\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\n__name(Range, \"Range\");\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\n__name(Position, \"Position\");\nexport { CharacterStream as C, Position as P, Range as R };\n","import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport { Kind, specifiedRules, NoUnusedFragmentsRule, ExecutableDefinitionsRule, KnownFragmentNamesRule, validate, LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, print, parse, NoDeprecatedCustomRule } from \"graphql\";\nimport \"./index.es.js\";\nimport { R as Range, P as Position, C as CharacterStream } from \"./Range.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport \"react\";\nimport \"react-dom\";\nconst specifiedSDLRules = [\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule\n];\nfunction validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n  const rules = specifiedRules.filter((rule) => {\n    if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n      return false;\n    }\n    if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n      return false;\n    }\n    return true;\n  });\n  if (customRules) {\n    Array.prototype.push.apply(rules, customRules);\n  }\n  if (isSchemaDocument) {\n    Array.prototype.push.apply(rules, specifiedSDLRules);\n  }\n  const errors = validate(schema, ast, rules);\n  return errors.filter((error) => {\n    if (error.message.indexOf(\"Unknown directive\") !== -1 && error.nodes) {\n      const node = error.nodes[0];\n      if (node && node.kind === Kind.DIRECTIVE) {\n        const name = node.name.value;\n        if (name === \"arguments\" || name === \"argumentDefinitions\") {\n          return false;\n        }\n      }\n    }\n    return true;\n  });\n}\n__name(validateWithCustomRules, \"validateWithCustomRules\");\nconst SEVERITY$1 = {\n  Error: \"Error\",\n  Warning: \"Warning\",\n  Information: \"Information\",\n  Hint: \"Hint\"\n};\nconst DIAGNOSTIC_SEVERITY = {\n  [SEVERITY$1.Error]: 1,\n  [SEVERITY$1.Warning]: 2,\n  [SEVERITY$1.Information]: 3,\n  [SEVERITY$1.Hint]: 4\n};\nconst invariant = /* @__PURE__ */ __name((condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n}, \"invariant\");\nfunction getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n  let ast = null;\n  if (externalFragments) {\n    if (typeof externalFragments === \"string\") {\n      query += \"\\n\\n\" + externalFragments;\n    } else {\n      query += \"\\n\\n\" + externalFragments.reduce((agg, node) => {\n        agg += print(node) + \"\\n\\n\";\n        return agg;\n      }, \"\");\n    }\n  }\n  try {\n    ast = parse(query);\n  } catch (error) {\n    const range = getRange(error.locations[0], query);\n    return [\n      {\n        severity: DIAGNOSTIC_SEVERITY.Error,\n        message: error.message,\n        source: \"GraphQL: Syntax\",\n        range\n      }\n    ];\n  }\n  return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\n__name(getDiagnostics, \"getDiagnostics\");\nfunction validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n  if (!schema) {\n    return [];\n  }\n  const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Error, \"Validation\"));\n  const deprecationWarningAnnotations = mapCat(validate(schema, ast, [NoDeprecatedCustomRule]), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Warning, \"Deprecation\"));\n  return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\n__name(validateQuery, \"validateQuery\");\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n__name(mapCat, \"mapCat\");\nfunction annotations(error, severity, type) {\n  if (!error.nodes) {\n    return [];\n  }\n  const highlightedNodes = [];\n  error.nodes.forEach((node) => {\n    const highlightNode = node.kind !== \"Variable\" && \"name\" in node && node.name !== void 0 ? node.name : \"variable\" in node && node.variable !== void 0 ? node.variable : node;\n    if (highlightNode) {\n      invariant(error.locations, \"GraphQL validation error requires locations.\");\n      const loc = error.locations[0];\n      const highlightLoc = getLocation(highlightNode);\n      const end = loc.column + (highlightLoc.end - highlightLoc.start);\n      highlightedNodes.push({\n        source: `GraphQL: ${type}`,\n        message: error.message,\n        severity,\n        range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end))\n      });\n    }\n  });\n  return highlightedNodes;\n}\n__name(annotations, \"annotations\");\nfunction getRange(location, queryText) {\n  const parser = onlineParser();\n  const state = parser.startState();\n  const lines = queryText.split(\"\\n\");\n  invariant(lines.length >= location.line, \"Query text must have more lines than where the error happened\");\n  let stream = null;\n  for (let i = 0; i < location.line; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      const style = parser.token(stream, state);\n      if (style === \"invalidchar\") {\n        break;\n      }\n    }\n  }\n  invariant(stream, \"Expected Parser stream to be available.\");\n  const line = location.line - 1;\n  const start = stream.getStartOfToken();\n  const end = stream.getCurrentPosition();\n  return new Range(new Position(line, start), new Position(line, end));\n}\n__name(getRange, \"getRange\");\nfunction getLocation(node) {\n  const typeCastedNode = node;\n  const location = typeCastedNode.loc;\n  invariant(location, \"Expected ASTNode to have a location.\");\n  return location;\n}\n__name(getLocation, \"getLocation\");\nconst SEVERITY = [\"error\", \"warning\", \"information\", \"hint\"];\nconst TYPE = {\n  \"GraphQL: Validation\": \"validation\",\n  \"GraphQL: Deprecation\": \"deprecation\",\n  \"GraphQL: Syntax\": \"syntax\"\n};\nCodeMirror.registerHelper(\"lint\", \"graphql\", (text, options) => {\n  const schema = options.schema;\n  const rawResults = getDiagnostics(text, schema, options.validationRules, void 0, options.externalFragments);\n  const results = rawResults.map((error) => ({\n    message: error.message,\n    severity: error.severity ? SEVERITY[error.severity - 1] : SEVERITY[0],\n    type: error.source ? TYPE[error.source] : void 0,\n    from: CodeMirror.Pos(error.range.start.line, error.range.start.character),\n    to: CodeMirror.Pos(error.range.end.line, error.range.end.character)\n  }));\n  return results;\n});\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\nfunction onlineParser(options = {\n  eatWhitespace: (stream) => stream.eatWhile(isIgnored),\n  lexRules: LexRules,\n  parseRules: ParseRules,\n  editorConfig: {}\n}) {\n  return {\n    startState() {\n      const initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n__name(onlineParser, \"onlineParser\");\nfunction getToken(stream, state, options) {\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n  if (stream.sol()) {\n    const tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n  const token = lex(lexRules, stream);\n  if (!token) {\n    const matchedSomething = stream.match(/\\S+/);\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n  const backupState = assign({}, state);\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      const levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n  while (state.rule) {\n    let expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n    if (state.needsSeperator) {\n      expected = expected && (expected === null || expected === void 0 ? void 0 : expected.separator);\n    }\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n__name(getToken, \"getToken\");\nfunction assign(to, from) {\n  const keys = Object.keys(from);\n  for (let i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n__name(assign, \"assign\");\nconst SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n}\n__name(pushRule, \"pushRule\");\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n}\n__name(popRule, \"popRule\");\nfunction advanceRule(state, successful) {\n  if (isList(state) && state.rule) {\n    const step = state.rule[state.step];\n    if (step.separator) {\n      const separator = step.separator;\n      state.needsSeperator = !state.needsSeperator;\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    }\n    if (successful) {\n      return;\n    }\n  }\n  state.needsSeperator = false;\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    if (state.rule) {\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n__name(advanceRule, \"advanceRule\");\nfunction isList(state) {\n  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n__name(isList, \"isList\");\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n__name(unsuccessful, \"unsuccessful\");\nfunction lex(lexRules, stream) {\n  const kinds = Object.keys(lexRules);\n  for (let i = 0; i < kinds.length; i++) {\n    const match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n__name(lex, \"lex\");\nexport { onlineParser as o };\n"],"sourceRoot":""}