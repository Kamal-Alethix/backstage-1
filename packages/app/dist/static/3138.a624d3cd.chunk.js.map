{"version":3,"sources":["webpack://example-app/javascript/node_modules/graphql/utilities/extendSchema.mjs","webpack://example-app/javascript/node_modules/graphql/utilities/buildASTSchema.mjs","webpack://example-app/../node_modules/@sucrase/webpack-loader/dist/plugins/api-docs/src/components/GraphQlDefinitionWidget/GraphQlDefinition.tsx"],"names":[],"mappings":"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","file":"static/3138.a624d3cd.chunk.js","sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../language/predicates.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport {\n  GraphQLDeprecatedDirective,\n  GraphQLDirective,\n  GraphQLSpecifiedByDirective,\n} from '../type/directives.mjs';\nimport {\n  introspectionTypes,\n  isIntrospectionType,\n} from '../type/introspection.mjs';\nimport {\n  isSpecifiedScalarType,\n  specifiedScalarTypes,\n} from '../type/scalars.mjs';\nimport { assertSchema, GraphQLSchema } from '../type/schema.mjs';\nimport { assertValidSDLExtension } from '../validation/validate.mjs';\nimport { getDirectiveValues } from '../execution/values.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  (documentAST != null && documentAST.kind === Kind.DOCUMENT) ||\n    devAssert(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig\n    ? schema\n    : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n\n  for (const def of documentAST.definitions) {\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions\n        ? existingTypeExtensions.concat([def])\n        : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (\n    Object.keys(typeExtensionsMap).length === 0 &&\n    typeDefs.length === 0 &&\n    directiveDefs.length === 0 &&\n    schemaExtensions.length === 0 &&\n    schemaDef == null\n  ) {\n    return schemaConfig;\n  }\n\n  const typeMap = Object.create(null);\n\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n\n    const name = typeNode.name.value;\n    typeMap[name] =\n      (_stdTypeMap$name = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name !== void 0\n        ? _stdTypeMap$name\n        : buildType(typeNode);\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription:\n      schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions),\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description:\n      (_schemaDef = schemaDef) === null || _schemaDef === void 0\n        ? void 0\n        : (_schemaDef$descriptio = _schemaDef.description) === null ||\n          _schemaDef$descriptio === void 0\n        ? void 0\n        : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [\n      ...schemaConfig.directives.map(replaceDirective),\n      ...directiveDefs.map(buildDirective),\n    ],\n    extensions: Object.create(null),\n    astNode:\n      (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0\n        ? _schemaDef2\n        : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid:\n      (_options$assumeValid =\n        options === null || options === void 0\n          ? void 0\n          : options.assumeValid) !== null && _options$assumeValid !== void 0\n        ? _options$assumeValid\n        : false,\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      args: mapValue(config.args, extendArg),\n    });\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    }\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co !== void 0\n        ? _typeExtensionsMap$co\n        : [];\n    return new GraphQLInputObjectType({\n      ...config,\n      fields: () => ({\n        ...mapValue(config.fields, (field) => ({\n          ...field,\n          type: replaceType(field.type),\n        })),\n        ...buildInputFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null &&\n      _typeExtensionsMap$ty !== void 0\n        ? _typeExtensionsMap$ty\n        : [];\n    return new GraphQLEnumType({\n      ...config,\n      values: { ...config.values, ...buildEnumValueMap(extensions) },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co2 !== void 0\n        ? _typeExtensionsMap$co2\n        : [];\n    let specifiedByURL = config.specifiedByURL;\n\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n\n      specifiedByURL =\n        (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null &&\n        _getSpecifiedByURL !== void 0\n          ? _getSpecifiedByURL\n          : specifiedByURL;\n    }\n\n    return new GraphQLScalarType({\n      ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co3 !== void 0\n        ? _typeExtensionsMap$co3\n        : [];\n    return new GraphQLObjectType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co4 !== void 0\n        ? _typeExtensionsMap$co4\n        : [];\n    return new GraphQLInterfaceType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co5 !== void 0\n        ? _typeExtensionsMap$co5\n        : [];\n    return new GraphQLUnionType({\n      ...config,\n      types: () => [\n        ...type.getTypes().map(replaceNamedType),\n        ...buildUnionTypes(extensions),\n      ],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendField(field) {\n    return {\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && mapValue(field.args, extendArg),\n    };\n  }\n\n  function extendArg(arg) {\n    return { ...arg, type: replaceType(arg.type) };\n  }\n\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n\n    for (const node of nodes) {\n      var _node$operationTypes;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const operationTypesNodes =\n        /* c8 ignore next */\n        (_node$operationTypes = node.operationTypes) !== null &&\n        _node$operationTypes !== void 0\n          ? _node$operationTypes\n          : [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    const name = node.name.value;\n    const type =\n      (_stdTypeMap$name2 = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name2 !== void 0\n        ? _stdTypeMap$name2\n        : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new GraphQLDirective({\n      name: node.name.value,\n      description:\n        (_node$description = node.description) === null ||\n        _node$description === void 0\n          ? void 0\n          : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(({ value }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node,\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const nodeFields =\n        /* c8 ignore next */\n        (_node$fields = node.fields) !== null && _node$fields !== void 0\n          ? _node$fields\n          : [];\n\n      for (const field of nodeFields) {\n        var _field$description;\n\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description:\n            (_field$description = field.description) === null ||\n            _field$description === void 0\n              ? void 0\n              : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    const argsNodes =\n      /* c8 ignore next */\n      args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n\n    for (const arg of argsNodes) {\n      var _arg$description;\n\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description:\n          (_arg$description = arg.description) === null ||\n          _arg$description === void 0\n            ? void 0\n            : _arg$description.value,\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg,\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields2;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const fieldsNodes =\n        /* c8 ignore next */\n        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0\n          ? _node$fields2\n          : [];\n\n      for (const field of fieldsNodes) {\n        var _field$description2;\n\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description:\n            (_field$description2 = field.description) === null ||\n            _field$description2 === void 0\n              ? void 0\n              : _field$description2.value,\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$values;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const valuesNodes =\n        /* c8 ignore next */\n        (_node$values = node.values) !== null && _node$values !== void 0\n          ? _node$values\n          : [];\n\n      for (const value of valuesNodes) {\n        var _value$description;\n\n        enumValueMap[value.name.value] = {\n          description:\n            (_value$description = value.description) === null ||\n            _value$description === void 0\n              ? void 0\n              : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value,\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$interfaces$map, _node$interfaces;\n\n        return (\n          /* c8 ignore next */\n          (_node$interfaces$map =\n            (_node$interfaces = node.interfaces) === null ||\n            _node$interfaces === void 0\n              ? void 0\n              : _node$interfaces.map(getNamedType)) !== null &&\n            _node$interfaces$map !== void 0\n            ? _node$interfaces$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$types$map, _node$types;\n\n        return (\n          /* c8 ignore next */\n          (_node$types$map =\n            (_node$types = node.types) === null || _node$types === void 0\n              ? void 0\n              : _node$types.map(getNamedType)) !== null &&\n            _node$types$map !== void 0\n            ? _node$types$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    const name = astNode.name.value;\n    const extensionASTNodes =\n      (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null &&\n      _typeExtensionsMap$na !== void 0\n        ? _typeExtensionsMap$na\n        : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION: {\n        var _astNode$description;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLObjectType({\n          name,\n          description:\n            (_astNode$description = astNode.description) === null ||\n            _astNode$description === void 0\n              ? void 0\n              : _astNode$description.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INTERFACE_TYPE_DEFINITION: {\n        var _astNode$description2;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInterfaceType({\n          name,\n          description:\n            (_astNode$description2 = astNode.description) === null ||\n            _astNode$description2 === void 0\n              ? void 0\n              : _astNode$description2.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.ENUM_TYPE_DEFINITION: {\n        var _astNode$description3;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLEnumType({\n          name,\n          description:\n            (_astNode$description3 = astNode.description) === null ||\n            _astNode$description3 === void 0\n              ? void 0\n              : _astNode$description3.value,\n          values: buildEnumValueMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.UNION_TYPE_DEFINITION: {\n        var _astNode$description4;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLUnionType({\n          name,\n          description:\n            (_astNode$description4 = astNode.description) === null ||\n            _astNode$description4 === void 0\n              ? void 0\n              : _astNode$description4.value,\n          types: () => buildUnionTypes(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.SCALAR_TYPE_DEFINITION: {\n        var _astNode$description5;\n\n        return new GraphQLScalarType({\n          name,\n          description:\n            (_astNode$description5 = astNode.description) === null ||\n            _astNode$description5 === void 0\n              ? void 0\n              : _astNode$description5.value,\n          specifiedByURL: getSpecifiedByURL(astNode),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n        var _astNode$description6;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInputObjectType({\n          name,\n          description:\n            (_astNode$description6 = astNode.description) === null ||\n            _astNode$description6 === void 0\n              ? void 0\n              : _astNode$description6.value,\n          fields: () => buildInputFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n    }\n  }\n}\nconst stdTypeMap = keyMap(\n  [...specifiedScalarTypes, ...introspectionTypes],\n  (type) => type.name,\n);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0\n    ? void 0\n    : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0\n    ? void 0\n    : specifiedBy.url;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { specifiedDirectives } from '../type/directives.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { assertValidSDL } from '../validation/validate.mjs';\nimport { extendSchemaImpl } from './extendSchema.mjs';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query,\n * Mutation and Subscription.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\nexport function buildASTSchema(documentAST, options) {\n  (documentAST != null && documentAST.kind === Kind.DOCUMENT) ||\n    devAssert(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    assertValidSDL(documentAST);\n  }\n\n  const emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: Object.create(null),\n    extensionASTNodes: [],\n    assumeValid: false,\n  };\n  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (const type of config.types) {\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          // @ts-expect-error validated in `validateSchema`\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          // @ts-expect-error validated in `validateSchema`\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          // @ts-expect-error validated in `validateSchema`\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  const directives = [\n    ...config.directives, // If specified directives were not explicitly declared, add them.\n    ...specifiedDirectives.filter((stdDirective) =>\n      config.directives.every(\n        (directive) => directive.name !== stdDirective.name,\n      ),\n    ),\n  ];\n  return new GraphQLSchema({ ...config, directives });\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  const document = parse(source, {\n    noLocation:\n      options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacyFragmentVariables:\n      options === null || options === void 0\n        ? void 0\n        : options.allowLegacyFragmentVariables,\n  });\n  return buildASTSchema(document, {\n    assumeValidSDL:\n      options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  });\n}\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { makeStyles } from '@material-ui/core/styles';\nimport GraphiQL from 'graphiql';\nimport 'graphiql/graphiql.css';\nimport { buildSchema } from 'graphql';\nimport React from 'react';\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    height: '100%',\n    display: 'flex',\n    flexFlow: 'column nowrap',\n  },\n  graphiQlWrapper: {\n    flex: 1,\n    '@global': {\n      '.graphiql-container': {\n        boxSizing: 'initial',\n        height: '100%',\n        minHeight: '600px',\n        flex: '1 1 auto',\n      },\n    },\n  },\n}));\n\n\n\n\n\nexport const GraphQlDefinition = ({ definition }) => {\n  const classes = useStyles();\n  const schema = buildSchema(definition);\n\n  return (\n    React.createElement('div', { className: classes.root,}\n      , React.createElement('div', { className: classes.graphiQlWrapper,}\n        , React.createElement(GraphiQL, {\n          fetcher: () => Promise.resolve(null) ,\n          schema: schema,\n          docExplorerOpen: true,\n          defaultSecondaryEditorOpen: false,}\n        )\n      )\n    )\n  );\n};\n"],"sourceRoot":""}